---
layout: post
title: Javaçº¿ç¨‹æ± 
category: other
tags: [other]
excerpt:  Javaçº¿ç¨‹æ± 
---

## å‰è¨€
åœ¨JavaæœåŠ¡å™¨å¼€å‘ä¸­ï¼ŒæœåŠ¡å™¨æ¥å—å¹¶å¤„ç†è¯·æ±‚ï¼Œæ˜¯é€šè¿‡çº¿ç¨‹åˆ›å»ºçº¿ç¨‹çš„æ–¹å¼æ¥å¤„ç†çš„ã€‚å¦‚æœæ¯æ¬¡è¯·æ±‚éƒ½æ–°åˆ›å»ºä¸€ä¸ªçº¿ç¨‹çš„è¯å®ç°èµ·æ¥éå¸¸ç®€ä¾¿ï¼Œ
ä½†æ˜¯å­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼š
å¦‚æœå¹¶å‘çš„è¯·æ±‚æ•°é‡éå¸¸å¤šï¼Œä½†æ¯ä¸ªçº¿ç¨‹æ‰§è¡Œçš„æ—¶é—´å¾ˆçŸ­ï¼Œè¿™æ ·å°±ä¼šé¢‘ç¹çš„åˆ›å»ºå’Œé”€æ¯çº¿ç¨‹ï¼Œå¦‚æ­¤ä¸€æ¥ä¼šå¤§å¤§é™ä½ç³»ç»Ÿçš„æ•ˆç‡ã€‚å¯èƒ½å‡ºç°æœåŠ¡å™¨åœ¨ä¸ºæ¯ä¸ªè¯·æ±‚
åˆ›å»ºæ–°çº¿ç¨‹å’Œé”€æ¯çº¿ç¨‹ä¸ŠèŠ±è´¹çš„æ—¶é—´å’Œæ¶ˆè€—çš„ç³»ç»Ÿèµ„æºè¦æ¯”å¤„ç†å®é™…çš„ç”¨æˆ·è¯·æ±‚çš„æ—¶é—´å’Œèµ„æºæ›´å¤šã€‚
çº¿ç¨‹æ± ä¸ºçº¿ç¨‹ç”Ÿå‘½å‘¨æœŸçš„å¼€é”€å’Œèµ„æºä¸è¶³é—®é¢˜æä¾›äº†è§£å†³æ–¹æ¡ˆã€‚é€šè¿‡å¯¹å¤šä¸ªä»»åŠ¡é‡ç”¨çº¿ç¨‹ï¼Œçº¿ç¨‹åˆ›å»ºçš„å¼€é”€è¢«åˆ†æ‘Šåˆ°äº†å¤šä¸ªä»»åŠ¡ä¸Šã€‚
ä»€ä¹ˆåœºæ™¯ä¸‹é€‚åˆä½¿ç”¨çº¿ç¨‹æ± ï¼Ÿ
- å•ä¸ªä»»åŠ¡å¤„ç†æ—¶é—´æ¯”è¾ƒçŸ­
- éœ€è¦å¤„ç†çš„ä»»åŠ¡æ•°é‡å¾ˆå¤§
ä½¿ç”¨çº¿ç¨‹æ± çš„å¥½å¤„æœ‰å“ªäº›ï¼Ÿ
- é™ä½èµ„æºæ¶ˆè€—ã€‚é€šè¿‡é‡å¤åˆ©ç”¨å·²åˆ›å»ºçš„çº¿ç¨‹é™ä½çº¿ç¨‹åˆ›å»ºå’Œé”€æ¯é€ æˆçš„æ¶ˆè€—ã€‚
- æé«˜å“åº”é€Ÿåº¦ã€‚å½“ä»»åŠ¡åˆ°è¾¾æ—¶ï¼Œä»»åŠ¡å¯ä»¥ä¸éœ€è¦çš„ç­‰åˆ°çº¿ç¨‹åˆ›å»ºå°±èƒ½ç«‹å³æ‰§è¡Œã€‚
- æé«˜çº¿ç¨‹çš„å¯ç®¡ç†æ€§ã€‚çº¿ç¨‹æ˜¯ç¨€ç¼ºèµ„æºï¼Œå¦‚æœæ— é™åˆ¶çš„åˆ›å»ºï¼Œä¸ä»…ä¼šæ¶ˆè€—ç³»ç»Ÿèµ„æºï¼Œè¿˜ä¼šé™ä½ç³»ç»Ÿçš„ç¨³å®šæ€§ï¼Œä½¿ç”¨çº¿ç¨‹æ± å¯ä»¥è¿›è¡Œç»Ÿä¸€çš„åˆ†é…ï¼Œè°ƒä¼˜å’Œç›‘æ§ã€‚

é—®é¢˜ï¼š
é€šè¿‡ä¸Šé¢çº¿ç¨‹æ± çš„ä»‹ç»ï¼Œçº¿ç¨‹æ± é¿å…äº†çº¿ç¨‹çš„é¢‘ç¹é”€æ¯å’Œåˆ›å»ºï¼Œè¿™ä¸ªæ˜¯å¦‚ä½•åšåˆ°çš„å‘¢ï¼Ÿ

## ThreadPoolExecutorè¯´æ˜

### é‡è¦æ¦‚å¿µ
ThreadPoolExecutorç»§æ‰¿è‡ªAbstractExecutorServiceï¼Œä¹Ÿæ˜¯å®ç°äº†ExecutorServiceæ¥å£ã€‚
```java
/***
    *   RUNNING:  Accept new tasks and process queued tasks
    *   SHUTDOWN: Don't accept new tasks, but process queued tasks
    *   STOP:     Don't accept new tasks, don't process queued tasks,
    *             and interrupt in-progress tasks
    *   TIDYING:  All tasks have terminated, workerCount is zero,
    *             the thread transitioning to state TIDYING
    *             will run the terminated() hook method
    *   TERMINATED: terminated() has completed
    * RUNNING -> SHUTDOWN
    *    On invocation of shutdown(), perhaps implicitly in finalize()
    * (RUNNING or SHUTDOWN) -> STOP
    *    On invocation of shutdownNow()
    * SHUTDOWN -> TIDYING
    *    When both queue and pool are empty
    * STOP -> TIDYING
    *    When pool is empty
    * TIDYING -> TERMINATED
    *    When the terminated() hook method has completed
*/
    private static final int COUNT_BITS = Integer.SIZE - 3;
    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

    // runState is stored in the high-order bits
    private static final int RUNNING    = -1 << COUNT_BITS;
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    private static final int STOP       =  1 << COUNT_BITS;
    private static final int TIDYING    =  2 << COUNT_BITS;
    private static final int TERMINATED =  3 << COUNT_BITS;
```
è¯´æ˜ï¼š
ctlæ˜¯å¯¹çº¿ç¨‹æ± çš„è¿è¡ŒçŠ¶æ€å’Œçº¿ç¨‹æ± ä¸­æœ‰æ•ˆçº¿ç¨‹çš„æ•°é‡è¿›è¡Œæ§åˆ¶çš„ä¸€ä¸ªå­—æ®µï¼Œ å®ƒåŒ…å«ä¸¤éƒ¨åˆ†çš„ä¿¡æ¯: 
çº¿ç¨‹æ± çš„è¿è¡ŒçŠ¶æ€ (runState) å’Œçº¿ç¨‹æ± å†…æœ‰æ•ˆçº¿ç¨‹çš„æ•°é‡ (workerCount)ï¼Œè¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œä½¿ç”¨äº†Integerç±»å‹æ¥ä¿å­˜ï¼Œé«˜3ä½ä¿å­˜runStateï¼Œ
ä½29ä½ä¿å­˜workerCountã€‚COUNT_BITS å°±æ˜¯29ï¼ŒCAPACITYå°±æ˜¯1å·¦ç§»29ä½å‡1ï¼ˆ29ä¸ª1ï¼‰ï¼Œè¿™ä¸ªå¸¸é‡è¡¨ç¤ºworkerCountçš„ä¸Šé™å€¼ï¼Œå¤§çº¦æ˜¯5äº¿ã€‚

çº¿ç¨‹æœ‰5ç§çŠ¶æ€ï¼šæ–°å»ºçŠ¶æ€ï¼Œå°±ç»ªçŠ¶æ€ï¼Œè¿è¡ŒçŠ¶æ€ï¼Œé˜»å¡çŠ¶æ€ï¼Œæ­»äº¡çŠ¶æ€ã€‚

```java
RUNNING    -- å¯¹åº”çš„é«˜3ä½å€¼æ˜¯111ã€‚
SHUTDOWN   -- å¯¹åº”çš„é«˜3ä½å€¼æ˜¯000ã€‚
STOP       -- å¯¹åº”çš„é«˜3ä½å€¼æ˜¯001ã€‚
TIDYING    -- å¯¹åº”çš„é«˜3ä½å€¼æ˜¯010ã€‚
TERMINATED -- å¯¹åº”çš„é«˜3ä½å€¼æ˜¯011ã€‚
```

çŠ¶æ€å˜åŒ–å¦‚ä¸‹ï¼š
![](/assets/images/2019/03/java_concurrent_threadpool_status.jpg)

ctlç›¸å…³è®¡ç®—æ–¹æ³•ï¼š
```java
private static int runStateOf(int c)     { return c & ~CAPACITY; }
private static int workerCountOf(int c)  { return c & CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }
```
- runStateOfï¼šè·å–è¿è¡ŒçŠ¶æ€ï¼›
- workerCountOfï¼šè·å–æ´»åŠ¨çº¿ç¨‹æ•°ï¼›
- ctlOfï¼šè·å–è¿è¡ŒçŠ¶æ€å’Œæ´»åŠ¨çº¿ç¨‹æ•°çš„å€¼ã€‚



### æ„é€ æ–¹æ³•
ä¸»è¦å®ç°ç±»ï¼š``ThreadPoolExecutor``ï¼Œæ ¸å¿ƒæ„é€ æ–¹æ³•å¦‚ä¸‹ï¼š
```java
    /**
     * Creates a new {@code ThreadPoolExecutor} with the given initial
     * parameters.
     *
     * @param corePoolSize the number of threads to keep in the pool, even
     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
     * @param maximumPoolSize the maximum number of threads to allow in the
     *        pool
     * @param keepAliveTime when the number of threads is greater than
     *        the core, this is the maximum time that excess idle threads
     *        will wait for new tasks before terminating.
     * @param unit the time unit for the {@code keepAliveTime} argument
     * @param workQueue the queue to use for holding tasks before they are
     *        executed.  This queue will hold only the {@code Runnable}
     *        tasks submitted by the {@code execute} method.
     * @param threadFactory the factory to use when the executor
     *        creates a new thread
     * @param handler the handler to use when execution is blocked
     *        because the thread bounds and queue capacities are reached
     * @throws IllegalArgumentException if one of the following holds:<br>
     *         {@code corePoolSize < 0}<br>
     *         {@code keepAliveTime < 0}<br>
     *         {@code maximumPoolSize <= 0}<br>
     *         {@code maximumPoolSize < corePoolSize}
     * @throws NullPointerException if {@code workQueue}
     *         or {@code threadFactory} or {@code handler} is null
     */
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler);

```
æ„é€ æ–¹æ³•ä¸­çš„å­—æ®µå«ä¹‰å¦‚ä¸‹ï¼š
- corePoolSizeï¼šæ ¸å¿ƒçº¿ç¨‹æ•°é‡ï¼Œå½“æœ‰æ–°ä»»åŠ¡åœ¨execute()æ–¹æ³•æäº¤æ—¶ï¼Œä¼šæ‰§è¡Œä»¥ä¸‹åˆ¤æ–­ï¼š
    - å¦‚æœè¿è¡Œçš„çº¿ç¨‹å°‘äº corePoolSizeï¼Œåˆ™åˆ›å»ºæ–°çº¿ç¨‹æ¥å¤„ç†ä»»åŠ¡ï¼Œå³ä½¿çº¿ç¨‹æ± ä¸­çš„å…¶ä»–çº¿ç¨‹æ˜¯ç©ºé—²çš„ï¼›
    - å¦‚æœçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡å¤§äºç­‰äº corePoolSize ä¸”å°äº maximumPoolSizeï¼Œåˆ™åªæœ‰å½“workQueueæ»¡æ—¶æ‰åˆ›å»ºæ–°çš„çº¿ç¨‹å»å¤„ç†ä»»åŠ¡ï¼›
    - å¦‚æœè®¾ç½®çš„corePoolSize å’Œ maximumPoolSizeç›¸åŒï¼Œåˆ™åˆ›å»ºçš„çº¿ç¨‹æ± çš„å¤§å°æ˜¯å›ºå®šçš„ï¼Œè¿™æ—¶å¦‚æœæœ‰æ–°ä»»åŠ¡æäº¤ï¼Œè‹¥workQueueæœªæ»¡ï¼Œåˆ™å°†è¯·æ±‚æ”¾
    å…¥workQueueä¸­ï¼Œç­‰å¾…æœ‰ç©ºé—²çš„çº¿ç¨‹å»ä»workQueueä¸­å–ä»»åŠ¡å¹¶å¤„ç†ï¼›
    - å¦‚æœè¿è¡Œçš„çº¿ç¨‹æ•°é‡å¤§äºç­‰äºmaximumPoolSizeï¼Œè¿™æ—¶å¦‚æœworkQueueå·²ç»æ»¡äº†ï¼Œåˆ™é€šè¿‡handleræ‰€æŒ‡å®šçš„ç­–ç•¥æ¥å¤„ç†ä»»åŠ¡ï¼›
æ‰€ä»¥ï¼Œä»»åŠ¡æäº¤æ—¶ï¼Œåˆ¤æ–­çš„é¡ºåºä¸º corePoolSize â€“> workQueue â€“> maximumPoolSizeã€‚
- maximumPoolSizeï¼šæœ€å¤§çº¿ç¨‹æ•°é‡ï¼›
- workQueueï¼šç­‰å¾…é˜Ÿåˆ—ï¼Œå½“ä»»åŠ¡æäº¤æ—¶ï¼Œå¦‚æœçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡å¤§äºç­‰äºcorePoolSizeçš„æ—¶å€™ï¼ŒæŠŠè¯¥ä»»åŠ¡å°è£…æˆä¸€ä¸ªWorkerå¯¹è±¡æ”¾å…¥ç­‰å¾…é˜Ÿåˆ—ï¼›é˜Ÿåˆ—ä¸»
è¦æœ‰ä»¥ä¸‹å‡ ç§å¤„ç†æ–¹å¼:
    - ç›´æ¥åˆ‡æ¢ï¼šè¿™ç§æ–¹å¼å¸¸ç”¨çš„é˜Ÿåˆ—æ˜¯SynchronousQueue
    - ä½¿ç”¨æ— ç•Œé˜Ÿåˆ—ï¼šä¸€èˆ¬ä½¿ç”¨åŸºäºé“¾è¡¨çš„é˜»å¡é˜Ÿåˆ—LinkedBlockingQueueã€‚å¦‚æœä½¿ç”¨è¿™ç§æ–¹å¼ï¼Œé‚£ä¹ˆçº¿ç¨‹æ± ä¸­èƒ½å¤Ÿåˆ›å»ºçš„æœ€å¤§çº¿ç¨‹æ•°å°±æ˜¯corePoolSize
    ï¼Œè€ŒmaximumPoolSizeå°±ä¸ä¼šèµ·ä½œç”¨äº†ï¼ˆåé¢ä¹Ÿä¼šè¯´åˆ°ï¼‰ã€‚å½“çº¿ç¨‹æ± ä¸­æ‰€æœ‰çš„æ ¸å¿ƒçº¿ç¨‹éƒ½æ˜¯RUNNINGçŠ¶æ€æ—¶ï¼Œè¿™æ—¶ä¸€ä¸ªæ–°çš„ä»»åŠ¡æäº¤å°±ä¼šæ”¾å…¥ç­‰å¾…é˜Ÿåˆ—ä¸­ã€‚
    - ä½¿ç”¨æœ‰ç•Œé˜Ÿåˆ—ï¼šä¸€èˆ¬ä½¿ç”¨ArrayBlockingQueueã€‚ä½¿ç”¨è¯¥æ–¹å¼å¯ä»¥å°†çº¿ç¨‹æ± çš„æœ€å¤§çº¿ç¨‹æ•°é‡é™åˆ¶ä¸ºmaximumPoolSizeï¼Œè¿™æ ·èƒ½å¤Ÿé™ä½èµ„æºçš„æ¶ˆè€—ï¼Œ
    ä½†åŒæ—¶è¿™ç§æ–¹å¼ä¹Ÿä½¿å¾—çº¿ç¨‹æ± å¯¹çº¿ç¨‹çš„è°ƒåº¦å˜å¾—æ›´å›°éš¾ï¼Œå› ä¸ºçº¿ç¨‹æ± å’Œé˜Ÿåˆ—çš„å®¹é‡éƒ½æ˜¯æœ‰é™çš„å€¼ï¼Œæ‰€ä»¥è¦æƒ³ä½¿çº¿ç¨‹æ± å¤„ç†ä»»åŠ¡çš„ååç‡è¾¾åˆ°ä¸€ä¸ªç›¸å¯¹åˆç†
    çš„èŒƒå›´ï¼Œåˆæƒ³ä½¿çº¿ç¨‹è°ƒåº¦ç›¸å¯¹ç®€å•ï¼Œå¹¶ä¸”è¿˜è¦å°½å¯èƒ½çš„é™ä½çº¿ç¨‹æ± å¯¹èµ„æºçš„æ¶ˆè€—ï¼Œå°±éœ€è¦åˆç†çš„è®¾ç½®è¿™ä¸¤ä¸ªæ•°é‡ã€‚
        - å¦‚æœè¦æƒ³é™ä½ç³»ç»Ÿèµ„æºçš„æ¶ˆè€—ï¼ˆåŒ…æ‹¬CPUçš„ä½¿ç”¨ç‡ï¼Œæ“ä½œç³»ç»Ÿèµ„æºçš„æ¶ˆè€—ï¼Œä¸Šä¸‹æ–‡ç¯å¢ƒåˆ‡æ¢çš„å¼€é”€ç­‰ï¼‰, å¯ä»¥è®¾ç½®è¾ƒå¤§çš„é˜Ÿåˆ—å®¹é‡å’Œè¾ƒå°çš„çº¿ç¨‹æ± 
        å®¹é‡, ä½†è¿™æ ·ä¹Ÿä¼šé™ä½çº¿ç¨‹å¤„ç†ä»»åŠ¡çš„ååé‡ã€‚
        - å¦‚æœæäº¤çš„ä»»åŠ¡ç»å¸¸å‘ç”Ÿé˜»å¡ï¼Œé‚£ä¹ˆå¯ä»¥è€ƒè™‘é€šè¿‡è°ƒç”¨ setMaximumPoolSize() æ–¹æ³•æ¥é‡æ–°è®¾å®šçº¿ç¨‹æ± çš„å®¹é‡ã€‚
        - å¦‚æœé˜Ÿåˆ—çš„å®¹é‡è®¾ç½®çš„è¾ƒå°ï¼Œé€šå¸¸éœ€è¦å°†çº¿ç¨‹æ± çš„å®¹é‡è®¾ç½®å¤§ä¸€ç‚¹ï¼Œè¿™æ ·CPUçš„ä½¿ç”¨ç‡ä¼šç›¸å¯¹çš„é«˜ä¸€äº›ã€‚ä½†å¦‚æœçº¿ç¨‹æ± çš„å®¹é‡è®¾ç½®çš„è¿‡å¤§ï¼Œåˆ™åœ¨æ
        äº¤çš„ä»»åŠ¡æ•°é‡å¤ªå¤šçš„æƒ…å†µä¸‹ï¼Œå¹¶å‘é‡ä¼šå¢åŠ ï¼Œé‚£ä¹ˆçº¿ç¨‹ä¹‹é—´çš„è°ƒåº¦å°±æ˜¯ä¸€ä¸ªè¦è€ƒè™‘çš„é—®é¢˜ï¼Œå› ä¸ºè¿™æ ·åè€Œæœ‰å¯èƒ½é™ä½å¤„ç†ä»»åŠ¡çš„ååé‡ã€‚
- keepAliveTimeï¼šçº¿ç¨‹æ± ç»´æŠ¤çº¿ç¨‹æ‰€å…è®¸çš„ç©ºé—²æ—¶é—´ã€‚å½“çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡å¤§äºcorePoolSizeçš„æ—¶å€™ï¼Œå¦‚æœè¿™æ—¶æ²¡æœ‰æ–°çš„ä»»åŠ¡æäº¤ï¼Œæ ¸å¿ƒçº¿ç¨‹å¤–çš„çº¿ç¨‹ä¸
ä¼šç«‹å³é”€æ¯ï¼Œè€Œæ˜¯ä¼šç­‰å¾…ï¼Œç›´åˆ°ç­‰å¾…çš„æ—¶é—´è¶…è¿‡äº†keepAliveTimeï¼›
- threadFactoryï¼šå®ƒæ˜¯ThreadFactoryç±»å‹çš„å˜é‡ï¼Œç”¨æ¥åˆ›å»ºæ–°çº¿ç¨‹ã€‚é»˜è®¤ä½¿ç”¨Executors.defaultThreadFactory() æ¥åˆ›å»ºçº¿ç¨‹ã€‚ä½¿ç”¨é»˜è®¤çš„
ThreadFactoryæ¥åˆ›å»ºçº¿ç¨‹æ—¶ï¼Œä¼šä½¿æ–°åˆ›å»ºçš„çº¿ç¨‹å…·æœ‰ç›¸åŒçš„NORM_PRIORITYä¼˜å…ˆçº§å¹¶ä¸”æ˜¯éå®ˆæŠ¤çº¿ç¨‹ï¼ŒåŒæ—¶ä¹Ÿè®¾ç½®äº†çº¿ç¨‹çš„åç§°ã€‚
handlerï¼šå®ƒæ˜¯RejectedExecutionHandlerç±»å‹çš„å˜é‡ï¼Œè¡¨ç¤ºçº¿ç¨‹æ± çš„é¥±å’Œç­–ç•¥ã€‚å¦‚æœé˜»å¡é˜Ÿåˆ—æ»¡äº†å¹¶ä¸”æ²¡æœ‰ç©ºé—²çš„çº¿ç¨‹ï¼Œè¿™æ—¶å¦‚æœç»§ç»­æäº¤ä»»åŠ¡ï¼Œå°±éœ€è¦
é‡‡å–ä¸€ç§ç­–ç•¥å¤„ç†è¯¥ä»»åŠ¡ã€‚çº¿ç¨‹æ± æä¾›äº†4ç§ç­–ç•¥ï¼š
    -AbortPolicyï¼šç›´æ¥æŠ›å‡ºå¼‚å¸¸ï¼Œè¿™æ˜¯é»˜è®¤ç­–ç•¥ï¼›
    - CallerRunsPolicyï¼šç”¨è°ƒç”¨è€…æ‰€åœ¨çš„çº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡ï¼›
    - DiscardOldestPolicyï¼šä¸¢å¼ƒé˜»å¡é˜Ÿåˆ—ä¸­é æœ€å‰çš„ä»»åŠ¡ï¼Œå¹¶æ‰§è¡Œå½“å‰ä»»åŠ¡ï¼›
    - DiscardPolicyï¼šç›´æ¥ä¸¢å¼ƒä»»åŠ¡ï¼›


## ä»£ç ç»†èŠ‚èµ°è¯»
> æ³¨ï¼šJDKç‰ˆæœ¬ï¼šjdk1.8.0_111ï¼Œå¸¦ä¸­æ–‡æ•°å­—ç¼–å·çš„ä¸­æ–‡æ³¨é‡Šæ˜¯æˆ‘æ·»åŠ çš„

### executeæ–¹æ³•å®ç°

```
    /**
     * Executes the given task sometime in the future.  The task
     * may execute in a new thread or in an existing pooled thread.
     *
     * If the task cannot be submitted for execution, either because this
     * executor has been shutdown or because its capacity has been reached,
     * the task is handled by the current {@code RejectedExecutionHandler}.
     *
     * @param command the task to execute
     * @throws RejectedExecutionException at discretion of
     *         {@code RejectedExecutionHandler}, if the task
     *         cannot be accepted for execution
     * @throws NullPointerException if {@code command} is null
     */
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */

        /*
         * cltè®°å½•ç€runStateå’ŒworkerCount
         */
        int c = ctl.get();
        
        /*
         * workerCountOfæ–¹æ³•å–å‡ºä½29ä½çš„å€¼ï¼Œè¡¨ç¤ºå½“å‰æ´»åŠ¨çš„çº¿ç¨‹æ•°ï¼›
         * å¦‚æœå½“å‰æ´»åŠ¨çº¿ç¨‹æ•°å°äºcorePoolSizeï¼Œåˆ™æ–°å»ºä¸€ä¸ªçº¿ç¨‹æ”¾å…¥çº¿ç¨‹æ± ä¸­ï¼›
         * å¹¶æŠŠä»»åŠ¡æ·»åŠ åˆ°è¯¥çº¿ç¨‹ä¸­ã€‚
         */
        if (workerCountOf(c) < corePoolSize) {
        /*
         * addWorkerä¸­çš„ç¬¬äºŒä¸ªå‚æ•°è¡¨ç¤ºé™åˆ¶æ·»åŠ çº¿ç¨‹çš„æ•°é‡æ˜¯æ ¹æ®corePoolSizeæ¥åˆ¤æ–­è¿˜æ˜¯maximumPoolSizeæ¥åˆ¤æ–­ï¼›
         * å¦‚æœä¸ºtrueï¼Œæ ¹æ®corePoolSizeæ¥åˆ¤æ–­ï¼›
         * å¦‚æœä¸ºfalseï¼Œåˆ™æ ¹æ®maximumPoolSizeæ¥åˆ¤æ–­
         */
            if (addWorker(command, true))
                return;
             /*
             * å¦‚æœæ·»åŠ å¤±è´¥ï¼Œåˆ™é‡æ–°è·å–ctlå€¼
             */
            c = ctl.get();
        }

        /*
         * å¦‚æœå½“å‰çº¿ç¨‹æ± æ˜¯è¿è¡ŒçŠ¶æ€å¹¶ä¸”ä»»åŠ¡æ·»åŠ åˆ°é˜Ÿåˆ—æˆåŠŸ
         */
        if (isRunning(c) && workQueue.offer(command)) {

            /**
             * é‡æ–°è·å–ctlå€¼
            **/
            int recheck = ctl.get();

            /*
             * å†æ¬¡åˆ¤æ–­çº¿ç¨‹æ± çš„è¿è¡ŒçŠ¶æ€ï¼Œå¦‚æœä¸æ˜¯è¿è¡ŒçŠ¶æ€ï¼Œç”±äºä¹‹å‰å·²ç»æŠŠcommandæ·»åŠ åˆ°workQueueä¸­äº†ï¼Œ
        	 * è¿™æ—¶éœ€è¦ç§»é™¤è¯¥command
        	 * æ‰§è¡Œè¿‡åé€šè¿‡handlerä½¿ç”¨æ‹’ç»ç­–ç•¥å¯¹è¯¥ä»»åŠ¡è¿›è¡Œå¤„ç†ï¼Œæ•´ä¸ªæ–¹æ³•è¿”å›
        	 */
            if (! isRunning(recheck) && remove(command))
                reject(command);
             /*
             * è·å–çº¿ç¨‹æ± ä¸­çš„æœ‰æ•ˆçº¿ç¨‹æ•°ï¼Œå¦‚æœæ•°é‡æ˜¯0ï¼Œåˆ™æ‰§è¡ŒaddWorkeræ–¹æ³•
             * è¿™é‡Œä¼ å…¥çš„å‚æ•°è¡¨ç¤ºï¼š
             * 1. ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºnullï¼Œè¡¨ç¤ºåœ¨çº¿ç¨‹æ± ä¸­åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œä½†ä¸å»å¯åŠ¨ï¼›
             * 2. ç¬¬äºŒä¸ªå‚æ•°ä¸ºfalseï¼Œå°†çº¿ç¨‹æ± çš„æœ‰é™çº¿ç¨‹æ•°é‡çš„ä¸Šé™è®¾ç½®ä¸ºmaximumPoolSizeï¼Œæ·»åŠ çº¿ç¨‹æ—¶æ ¹æ®maximumPoolSizeæ¥åˆ¤æ–­ï¼›
             * å¦‚æœåˆ¤æ–­workerCountå¤§äº0ï¼Œåˆ™ç›´æ¥è¿”å›ï¼Œåœ¨workQueueä¸­æ–°å¢çš„commandä¼šåœ¨å°†æ¥çš„æŸä¸ªæ—¶åˆ»è¢«æ‰§è¡Œã€‚
             */
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }

        /*
         * å¦‚æœæ‰§è¡Œåˆ°è¿™é‡Œï¼Œæœ‰ä¸¤ç§æƒ…å†µï¼š
         * 1. çº¿ç¨‹æ± å·²ç»ä¸æ˜¯RUNNINGçŠ¶æ€ï¼›
         * 2. çº¿ç¨‹æ± æ˜¯RUNNINGçŠ¶æ€ï¼Œä½†workerCount >= corePoolSizeå¹¶ä¸”workQueueå·²æ»¡ã€‚
         * è¿™æ—¶ï¼Œå†æ¬¡è°ƒç”¨addWorkeræ–¹æ³•ï¼Œä½†ç¬¬äºŒä¸ªå‚æ•°ä¼ å…¥ä¸ºfalseï¼Œå°†çº¿ç¨‹æ± çš„æœ‰é™çº¿ç¨‹æ•°é‡çš„ä¸Šé™è®¾ç½®ä¸ºmaximumPoolSizeï¼›
         * å¦‚æœå¤±è´¥åˆ™æ‹’ç»è¯¥ä»»åŠ¡
         */
        else if (!addWorker(command, false))
            reject(command);
    }
```
ç®€å•æ¥è¯´ï¼Œåœ¨æ‰§è¡Œexecute()æ–¹æ³•æ—¶å¦‚æœçŠ¶æ€ä¸€ç›´æ˜¯RUNNINGæ—¶ï¼Œçš„æ‰§è¡Œè¿‡ç¨‹å¦‚ä¸‹ï¼š
- å¦‚æœworkerCount < corePoolSizeï¼Œåˆ™åˆ›å»ºå¹¶å¯åŠ¨ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œæ–°æäº¤çš„ä»»åŠ¡ï¼›
- å¦‚æœworkerCount >= corePoolSizeï¼Œä¸”çº¿ç¨‹æ± å†…çš„é˜»å¡é˜Ÿåˆ—æœªæ»¡ï¼Œåˆ™å°†ä»»åŠ¡æ·»åŠ åˆ°è¯¥é˜»å¡é˜Ÿåˆ—ä¸­ï¼›
- å¦‚æœworkerCount >= corePoolSize && workerCount < maximumPoolSizeï¼Œä¸”çº¿ç¨‹æ± å†…çš„é˜»å¡é˜Ÿåˆ—å·²æ»¡ï¼Œåˆ™åˆ›å»ºå¹¶å¯åŠ¨ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œæ–°æäº¤çš„ä»»åŠ¡ï¼›
- å¦‚æœworkerCount >= maximumPoolSizeï¼Œå¹¶ä¸”çº¿ç¨‹æ± å†…çš„é˜»å¡é˜Ÿåˆ—å·²æ»¡, åˆ™æ ¹æ®æ‹’ç»ç­–ç•¥æ¥å¤„ç†è¯¥ä»»åŠ¡, é»˜è®¤çš„å¤„ç†æ–¹å¼æ˜¯ç›´æ¥æŠ›å¼‚å¸¸ã€‚
è¿™é‡Œè¦æ³¨æ„ä¸€ä¸‹addWorker(null, false);ï¼Œä¹Ÿå°±æ˜¯åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œä½†å¹¶æ²¡æœ‰ä¼ å…¥ä»»åŠ¡ï¼Œå› ä¸ºä»»åŠ¡å·²ç»è¢«æ·»åŠ åˆ°workQueueä¸­äº†ï¼Œæ‰€ä»¥workeråœ¨æ‰§è¡Œçš„æ—¶å€™ï¼Œä¼šç›´æ¥ä»workQueueä¸­è·å–ä»»åŠ¡ã€‚æ‰€ä»¥ï¼Œåœ¨workerCountOf(recheck) == 0æ—¶æ‰§è¡ŒaddWorker(null, false);ä¹Ÿæ˜¯ä¸ºäº†ä¿è¯çº¿ç¨‹æ± åœ¨RUNNINGçŠ¶æ€ä¸‹å¿…é¡»è¦æœ‰ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡ã€‚

executeæ–¹æ³•æ‰§è¡Œæµç¨‹å¦‚ä¸‹ï¼š
![](/assets/images/2019/03/java_concurrent_threadpool_process.png)

### addWorkerçš„æ–¹æ³•
addWorkeræ–¹æ³•çš„ä¸»è¦å·¥ä½œæ˜¯åœ¨çº¿ç¨‹æ± ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹å¹¶æ‰§è¡Œï¼ŒfirstTaskå‚æ•° ç”¨äºæŒ‡å®šæ–°å¢çš„çº¿ç¨‹æ‰§è¡Œçš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼Œcoreå‚æ•°ä¸ºtrueè¡¨ç¤ºåœ¨æ–°å¢çº¿ç¨‹æ—¶ä¼šåˆ¤æ–­å½“å‰æ´»åŠ¨çº¿ç¨‹æ•°æ˜¯å¦å°‘äºcorePoolSizeï¼Œfalseè¡¨ç¤ºæ–°å¢çº¿ç¨‹å‰éœ€è¦åˆ¤æ–­å½“å‰æ´»åŠ¨çº¿ç¨‹æ•°æ˜¯å¦å°‘äºmaximumPoolSizeï¼Œä»£ç å¦‚ä¸‹addWorkeræ–¹æ³•çš„ä¸»è¦å·¥ä½œæ˜¯åœ¨çº¿ç¨‹æ± ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹å¹¶æ‰§è¡Œï¼ŒfirstTaskå‚æ•° ç”¨äºæŒ‡å®šæ–°å¢çš„çº¿ç¨‹æ‰§è¡Œçš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼Œcoreå‚æ•°ä¸ºtrueè¡¨ç¤ºåœ¨æ–°å¢çº¿ç¨‹æ—¶ä¼šåˆ¤æ–­å½“å‰æ´»åŠ¨çº¿ç¨‹æ•°æ˜¯å¦å°‘äºcorePoolSizeï¼Œfalseè¡¨ç¤ºæ–°å¢çº¿ç¨‹å‰éœ€è¦åˆ¤æ–­å½“å‰æ´»åŠ¨çº¿ç¨‹æ•°æ˜¯å¦å°‘äºmaximumPoolSizeï¼Œä»£ç å¦‚ä¸‹

```java
    /**
     * Checks if a new worker can be added with respect to current
     * pool state and the given bound (either core or maximum). If so,
     * the worker count is adjusted accordingly, and, if possible, a
     * new worker is created and started, running firstTask as its
     * first task. This method returns false if the pool is stopped or
     * eligible to shut down. It also returns false if the thread
     * factory fails to create a thread when asked.  If the thread
     * creation fails, either due to the thread factory returning
     * null, or due to an exception (typically OutOfMemoryError in
     * Thread.start()), we roll back cleanly.
     *
     * @param firstTask the task the new thread should run first (or
     * null if none). Workers are created with an initial first task
     * (in method execute()) to bypass queuing when there are fewer
     * than corePoolSize threads (in which case we always start one),
     * or when the queue is full (in which case we must bypass queue).
     * Initially idle threads are usually created via
     * prestartCoreThread or to replace other dying workers.
     *
     * @param core if true use corePoolSize as bound, else
     * maximumPoolSize. (A boolean indicator is used here rather than a
     * value to ensure reads of fresh values after checking other pool
     * state).
     * @return true if successful
     */
    private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {

	         /* 
	         * è·å–è¿è¡ŒçŠ¶æ€
	         */
            int c = ctl.get();
            int rs = runStateOf(c);

	        /*
	         * è¿™ä¸ªifåˆ¤æ–­
	         * å¦‚æœrs >= SHUTDOWNï¼Œåˆ™è¡¨ç¤ºæ­¤æ—¶ä¸å†æ¥æ”¶æ–°ä»»åŠ¡ï¼›
	         * æ¥ç€åˆ¤æ–­ä»¥ä¸‹3ä¸ªæ¡ä»¶ï¼Œåªè¦æœ‰1ä¸ªä¸æ»¡è¶³ï¼Œåˆ™è¿”å›falseï¼š
	         * 1. rs == SHUTDOWNï¼Œè¿™æ—¶è¡¨ç¤ºå…³é—­çŠ¶æ€ï¼Œä¸å†æ¥å—æ–°æäº¤çš„ä»»åŠ¡ï¼Œä½†å´å¯ä»¥ç»§ç»­å¤„ç†é˜»å¡é˜Ÿåˆ—ä¸­å·²ä¿å­˜çš„ä»»åŠ¡
	         * 2. firsTaskä¸ºç©º
	         * 3. é˜»å¡é˜Ÿåˆ—ä¸ä¸ºç©º
	         * 
	         * é¦–å…ˆè€ƒè™‘rs == SHUTDOWNçš„æƒ…å†µ
	         * è¿™ç§æƒ…å†µä¸‹ä¸ä¼šæ¥å—æ–°æäº¤çš„ä»»åŠ¡ï¼Œæ‰€ä»¥åœ¨firstTaskä¸ä¸ºç©ºçš„æ—¶å€™ä¼šè¿”å›falseï¼›
	         * ç„¶åï¼Œå¦‚æœfirstTaskä¸ºç©ºï¼Œå¹¶ä¸”workQueueä¹Ÿä¸ºç©ºï¼Œåˆ™è¿”å›falseï¼Œ
	         * å› ä¸ºé˜Ÿåˆ—ä¸­å·²ç»æ²¡æœ‰ä»»åŠ¡äº†ï¼Œä¸éœ€è¦å†æ·»åŠ çº¿ç¨‹äº†
	         */
            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                /* 
                 * è·å–çº¿ç¨‹æ•°
                 */
                int wc = workerCountOf(c);
	            /*
	             * å¦‚æœwcè¶…è¿‡CAPACITYï¼Œä¹Ÿå°±æ˜¯ctlçš„ä½29ä½çš„æœ€å¤§å€¼ï¼ˆäºŒè¿›åˆ¶æ˜¯29ä¸ª1ï¼‰ï¼Œè¿”å›falseï¼›
	             * è¿™é‡Œçš„coreæ˜¯addWorkeræ–¹æ³•çš„ç¬¬äºŒä¸ªå‚æ•°ï¼Œå¦‚æœä¸ºtrueè¡¨ç¤ºæ ¹æ®corePoolSizeæ¥æ¯”è¾ƒï¼Œ
	             * å¦‚æœä¸ºfalseåˆ™æ ¹æ®maximumPoolSizeæ¥æ¯”è¾ƒã€‚
	             */
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                /*
                 * å°è¯•å¢åŠ workerCountï¼Œå¦‚æœæˆåŠŸï¼Œåˆ™è·³å‡ºç¬¬ä¸€ä¸ªforå¾ªç¯
                 */
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                /*
                 * å¦‚æœå¢åŠ workerCountå¤±è´¥ï¼Œåˆ™é‡æ–°è·å–ctlçš„å€¼
                 */ 
                c = ctl.get();  // Re-read ctl
                /*
                 * å¦‚æœå½“å‰çš„è¿è¡ŒçŠ¶æ€ä¸ç­‰äºrsï¼Œè¯´æ˜çŠ¶æ€å·²è¢«æ”¹å˜ï¼Œè¿”å›ç¬¬ä¸€ä¸ªforå¾ªç¯ç»§ç»­æ‰§è¡Œ
                 */
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {

            /*
             * æ ¹æ®firstTaskæ¥åˆ›å»ºWorkerå¯¹è±¡
             * æ¯ä¸€ä¸ªWorkerå¯¹è±¡éƒ½ä¼šåˆ›å»ºä¸€ä¸ªçº¿ç¨‹
             */
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    /*
                     * rs < SHUTDOWNè¡¨ç¤ºæ˜¯RUNNINGçŠ¶æ€ï¼›
                     * å¦‚æœrsæ˜¯RUNNINGçŠ¶æ€æˆ–è€…rsæ˜¯SHUTDOWNçŠ¶æ€å¹¶ä¸”firstTaskä¸ºnullï¼Œå‘çº¿ç¨‹æ± ä¸­æ·»åŠ çº¿ç¨‹ã€‚
                     * å› ä¸ºåœ¨SHUTDOWNæ—¶ä¸ä¼šåœ¨æ·»åŠ æ–°çš„ä»»åŠ¡ï¼Œä½†è¿˜æ˜¯ä¼šæ‰§è¡ŒworkQueueä¸­çš„ä»»åŠ¡
                     */
                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        /*
                         * workersæ˜¯ä¸€ä¸ªHashSetï¼Œç”¨äºå­˜å‚¨æ‰§è¡Œçš„ä»»åŠ¡
                         */    
                        workers.add(w);
                        int s = workers.size();
                        /*
                         * largestPoolSizeè®°å½•ç€çº¿ç¨‹æ± ä¸­å‡ºç°è¿‡çš„æœ€å¤§çº¿ç¨‹æ•°é‡
                         */
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
            		/*
            		 * ä»»åŠ¡æ·»åŠ æˆåŠŸï¼Œå¯åŠ¨çº¿ç¨‹
            		 */
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```
æ³¨æ„ï¼š
t.start()è¿™ä¸ªè¯­å¥ï¼Œå¯åŠ¨æ—¶ä¼šè°ƒç”¨Workerç±»ä¸­çš„runæ–¹æ³•ï¼ŒWorkeræœ¬èº«å®ç°äº†Runnableæ¥å£ï¼Œæ‰€ä»¥ä¸€ä¸ªWorkerç±»å‹çš„å¯¹è±¡ä¹Ÿæ˜¯ä¸€ä¸ªçº¿ç¨‹ã€‚

### Workerç±»
çº¿ç¨‹æ± ä¸­çš„æ¯ä¸€ä¸ªçº¿ç¨‹è¢«å°è£…æˆä¸€ä¸ªWorkerå¯¹è±¡ï¼ŒThreadPoolç»´æŠ¤çš„å…¶å®å°±æ˜¯ä¸€ç»„Workerå¯¹è±¡ï¼Œä¸‹é¢æ˜¯Workerç±»å®šä¹‰ï¼š
```java
    /**
     * Class Worker mainly maintains interrupt control state for
     * threads running tasks, along with other minor bookkeeping.
     * This class opportunistically extends AbstractQueuedSynchronizer
     * to simplify acquiring and releasing a lock surrounding each
     * task execution.  This protects against interrupts that are
     * intended to wake up a worker thread waiting for a task from
     * instead interrupting a task being run.  We implement a simple
     * non-reentrant mutual exclusion lock rather than use
     * ReentrantLock because we do not want worker tasks to be able to
     * reacquire the lock when they invoke pool control methods like
     * setCorePoolSize.  Additionally, to suppress interrupts until
     * the thread actually starts running tasks, we initialize lock
     * state to a negative value, and clear it upon start (in
     * runWorker).
     */
    private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
        /**
         * This class will never be serialized, but we provide a
         * serialVersionUID to suppress a javac warning.
         */
        private static final long serialVersionUID = 6138294804551838833L;

        /** Thread this worker is running in.  Null if factory fails. */
        final Thread thread;
        /** Initial task to run.  Possibly null. */
        Runnable firstTask;
        /** Per-thread task counter */
        volatile long completedTasks;

        /**
         * Creates with given first task and thread from ThreadFactory.
         * @param firstTask the first task (null if none)
         */
        Worker(Runnable firstTask) {
            // state AQSçš„çŠ¶æ€ï¼Œè®¾ç½®ç¦æ­¢ä¸­æ–­ï¼Œç›´åˆ°è¿è¡Œå·¥ä½œç¨‹åº
            setState(-1); // inhibit interrupts until runWorker
            // æ‰§è¡Œçš„Runnableä»»åŠ¡ï¼Œç„¶åé€šè¿‡çº¿ç¨‹å·¥å‚åˆ›å»ºçº¿ç¨‹ 
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

        /** Delegates main run loop to outer runWorker  */
        public void run() {
            runWorker(this);
        }

        // Lock methods
        //
        // The value 0 represents the unlocked state.
        // The value 1 represents the locked state.

        protected boolean isHeldExclusively() {
            return getState() != 0;
        }

        protected boolean tryAcquire(int unused) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        protected boolean tryRelease(int unused) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        public void lock()        { acquire(1); }
        public boolean tryLock()  { return tryAcquire(1); }
        public void unlock()      { release(1); }
        public boolean isLocked() { return isHeldExclusively(); }

        void interruptIfStarted() {
            Thread t;
            if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                }
            }
        }
    }

```
Workerç±»ç»§æ‰¿äº†AQSï¼Œå¹¶å®ç°äº†Runnableæ¥å£ï¼Œæ³¨æ„å…¶ä¸­çš„firstTaskå’Œthreadå±æ€§ï¼šfirstTaskç”¨å®ƒæ¥ä¿å­˜ä¼ å…¥çš„ä»»åŠ¡ï¼›threadæ˜¯åœ¨è°ƒç”¨æ„é€ æ–¹æ³•æ—¶é€šè¿‡ThreadFactoryæ¥åˆ›å»ºçš„çº¿ç¨‹ï¼Œæ˜¯ç”¨æ¥å¤„ç†ä»»åŠ¡çš„çº¿ç¨‹ã€‚

åœ¨è°ƒç”¨æ„é€ æ–¹æ³•æ—¶ï¼Œéœ€è¦æŠŠä»»åŠ¡ä¼ å…¥ï¼Œè¿™é‡Œé€šè¿‡getThreadFactory().newThread(this);æ¥æ–°å»ºä¸€ä¸ªçº¿ç¨‹ï¼ŒnewThreadæ–¹æ³•ä¼ å…¥çš„å‚æ•°æ˜¯thisï¼Œå› ä¸ºWorkeræœ¬èº«ç»§æ‰¿äº†Runnableæ¥å£ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªçº¿ç¨‹ï¼Œæ‰€ä»¥ä¸€ä¸ªWorkerå¯¹è±¡åœ¨å¯åŠ¨çš„æ—¶å€™ä¼šè°ƒç”¨Workerç±»ä¸­çš„runæ–¹æ³•ã€‚

Workerç»§æ‰¿äº†AQSï¼Œä½¿ç”¨AQSæ¥å®ç°ç‹¬å é”çš„åŠŸèƒ½ã€‚ä¸ºä»€ä¹ˆä¸ä½¿ç”¨ReentrantLockæ¥å®ç°å‘¢ï¼Ÿå¯ä»¥çœ‹åˆ°tryAcquireæ–¹æ³•ï¼Œå®ƒæ˜¯ä¸å…è®¸é‡å…¥çš„ï¼Œè€ŒReentrantLockæ˜¯å…è®¸é‡å…¥çš„ï¼š

- lockæ–¹æ³•ä¸€æ—¦è·å–äº†ç‹¬å é”ï¼Œè¡¨ç¤ºå½“å‰çº¿ç¨‹æ­£åœ¨æ‰§è¡Œä»»åŠ¡ä¸­ï¼›
- å¦‚æœæ­£åœ¨æ‰§è¡Œä»»åŠ¡ï¼Œåˆ™ä¸åº”è¯¥ä¸­æ–­çº¿ç¨‹ï¼›
- å¦‚æœè¯¥çº¿ç¨‹ç°åœ¨ä¸æ˜¯ç‹¬å é”çš„çŠ¶æ€ï¼Œä¹Ÿå°±æ˜¯ç©ºé—²çš„çŠ¶æ€ï¼Œè¯´æ˜å®ƒæ²¡æœ‰åœ¨å¤„ç†ä»»åŠ¡ï¼Œè¿™æ—¶å¯ä»¥å¯¹è¯¥çº¿ç¨‹è¿›è¡Œä¸­æ–­ï¼›
- çº¿ç¨‹æ± åœ¨æ‰§è¡Œshutdownæ–¹æ³•æˆ–tryTerminateæ–¹æ³•æ—¶ä¼šè°ƒç”¨interruptIdleWorkersæ–¹æ³•æ¥ä¸­æ–­ç©ºé—²çš„çº¿ç¨‹ï¼ŒinterruptIdleWorkersæ–¹æ³•ä¼šä½¿ç”¨tryLockæ–¹æ³•æ¥åˆ¤æ–­çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ˜¯å¦æ˜¯ç©ºé—²çŠ¶æ€ï¼›
ä¹‹æ‰€ä»¥è®¾ç½®ä¸ºä¸å¯é‡å…¥ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬ä¸å¸Œæœ›ä»»åŠ¡åœ¨è°ƒç”¨åƒsetCorePoolSizeè¿™æ ·çš„çº¿ç¨‹æ± æ§åˆ¶æ–¹æ³•æ—¶é‡æ–°è·å–é”ã€‚å¦‚æœä½¿ç”¨ReentrantLockï¼Œå®ƒæ˜¯å¯é‡å…¥çš„ï¼Œè¿™æ ·å¦‚æœåœ¨ä»»åŠ¡ä¸­è°ƒç”¨äº†å¦‚setCorePoolSizeè¿™ç±»çº¿ç¨‹æ± æ§åˆ¶çš„æ–¹æ³•ï¼Œä¼šä¸­æ–­æ­£åœ¨è¿è¡Œçš„çº¿ç¨‹ã€‚
æ‰€ä»¥ï¼ŒWorkerç»§æ‰¿è‡ªAQSï¼Œç”¨äºåˆ¤æ–­çº¿ç¨‹æ˜¯å¦ç©ºé—²ä»¥åŠæ˜¯å¦å¯ä»¥è¢«ä¸­æ–­ã€‚

æ­¤å¤–ï¼Œåœ¨æ„é€ æ–¹æ³•ä¸­æ‰§è¡Œäº†setState(-1);ï¼ŒæŠŠstateå˜é‡è®¾ç½®ä¸º-1ï¼Œä¸ºä»€ä¹ˆè¿™ä¹ˆåšå‘¢ï¼Ÿæ˜¯å› ä¸ºAQSä¸­é»˜è®¤çš„stateæ˜¯0ï¼Œå¦‚æœåˆšåˆ›å»ºäº†ä¸€ä¸ªWorkerå¯¹è±¡ï¼Œè¿˜æ²¡æœ‰æ‰§è¡Œä»»åŠ¡æ—¶ï¼Œè¿™æ—¶å°±ä¸åº”è¯¥è¢«ä¸­æ–­ï¼Œçœ‹ä¸€ä¸‹tryAquireæ–¹æ³•ï¼š
```java
protected boolean tryAcquire(int unused) {
    if (compareAndSetState(0, 1)) {
        setExclusiveOwnerThread(Thread.currentThread());
        return true;
    }
    return false;
}
```
tryAcquireæ–¹æ³•æ˜¯æ ¹æ®stateæ˜¯å¦æ˜¯0æ¥åˆ¤æ–­çš„ï¼Œæ‰€ä»¥ï¼ŒsetState(-1);å°†stateè®¾ç½®ä¸º-1æ˜¯ä¸ºäº†ç¦æ­¢åœ¨æ‰§è¡Œä»»åŠ¡å‰å¯¹çº¿ç¨‹è¿›è¡Œä¸­æ–­ã€‚

æ­£å› ä¸ºå¦‚æ­¤ï¼Œåœ¨runWorkeræ–¹æ³•ä¸­ä¼šå…ˆè°ƒç”¨Workerå¯¹è±¡çš„unlockæ–¹æ³•å°†stateè®¾ç½®ä¸º0.

### runWorkeræ–¹æ³•
åœ¨Workerç±»ä¸­çš„runæ–¹æ³•è°ƒç”¨äº†runWorkeræ–¹æ³•æ¥æ‰§è¡Œä»»åŠ¡ï¼ŒrunWorkeræ–¹æ³•çš„ä»£ç å¦‚ä¸‹ï¼š
```java
    /**
     * Main worker run loop.  Repeatedly gets tasks from queue and
     * executes them, while coping with a number of issues:
     *
     * 1. We may start out with an initial task, in which case we
     * don't need to get the first one. Otherwise, as long as pool is
     * running, we get tasks from getTask. If it returns null then the
     * worker exits due to changed pool state or configuration
     * parameters.  Other exits result from exception throws in
     * external code, in which case completedAbruptly holds, which
     * usually leads processWorkerExit to replace this thread.
     *
     * 2. Before running any task, the lock is acquired to prevent
     * other pool interrupts while the task is executing, and then we
     * ensure that unless pool is stopping, this thread does not have
     * its interrupt set.
     *
     * 3. Each task run is preceded by a call to beforeExecute, which
     * might throw an exception, in which case we cause thread to die
     * (breaking loop with completedAbruptly true) without processing
     * the task.
     *
     * 4. Assuming beforeExecute completes normally, we run the task,
     * gathering any of its thrown exceptions to send to afterExecute.
     * We separately handle RuntimeException, Error (both of which the
     * specs guarantee that we trap) and arbitrary Throwables.
     * Because we cannot rethrow Throwables within Runnable.run, we
     * wrap them within Errors on the way out (to the thread's
     * UncaughtExceptionHandler).  Any thrown exception also
     * conservatively causes thread to die.
     *
     * 5. After task.run completes, we call afterExecute, which may
     * also throw an exception, which will also cause thread to
     * die. According to JLS Sec 14.20, this exception is the one that
     * will be in effect even if task.run throws.
     *
     * The net effect of the exception mechanics is that afterExecute
     * and the thread's UncaughtExceptionHandler have as accurate
     * information as we can provide about any problems encountered by
     * user code.
     *
     * @param w the worker
     */
    final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        /*
         * è·å–ç¬¬ä¸€ä¸ªä»»åŠ¡
         */
        Runnable task = w.firstTask;
        w.firstTask = null;
        /*
         * å…è®¸ä¸­æ–­
         */ 
        w.unlock(); // allow interrupts
        /*
         * æ˜¯å¦å› ä¸ºå¼‚å¸¸é€€å‡ºå¾ªç¯
         */
        boolean completedAbruptly = true;
        try {
            
    	   /*
    	    * å¦‚æœtaskä¸ºç©ºï¼Œåˆ™é€šè¿‡getTaskæ¥è·å–ä»»åŠ¡ã€‚
            */
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        /*
                         * ä»»åŠ¡æ‰§è¡Œ
                         */
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }

```
è¿™é‡Œè¯´æ˜ä¸€ä¸‹ç¬¬ä¸€ä¸ªifåˆ¤æ–­ï¼Œç›®çš„æ˜¯ï¼š

- å¦‚æœçº¿ç¨‹æ± æ­£åœ¨åœæ­¢ï¼Œé‚£ä¹ˆè¦ä¿è¯å½“å‰çº¿ç¨‹æ˜¯ä¸­æ–­çŠ¶æ€ï¼›
- å¦‚æœä¸æ˜¯çš„è¯ï¼Œåˆ™è¦ä¿è¯å½“å‰çº¿ç¨‹ä¸æ˜¯ä¸­æ–­çŠ¶æ€ï¼›
è¿™é‡Œè¦è€ƒè™‘åœ¨æ‰§è¡Œè¯¥ifè¯­å¥æœŸé—´å¯èƒ½ä¹Ÿæ‰§è¡Œäº†shutdownNowæ–¹æ³•ï¼ŒshutdownNowæ–¹æ³•ä¼šæŠŠçŠ¶æ€è®¾ç½®ä¸ºSTOPï¼Œå›é¡¾ä¸€ä¸‹STOPçŠ¶æ€ï¼š

> ä¸èƒ½æ¥å—æ–°ä»»åŠ¡ï¼Œä¹Ÿä¸å¤„ç†é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼Œä¼šä¸­æ–­æ­£åœ¨å¤„ç†ä»»åŠ¡çš„çº¿ç¨‹ã€‚åœ¨çº¿ç¨‹æ± å¤„äº RUNNING æˆ– SHUTDOWN çŠ¶æ€æ—¶ï¼Œè°ƒç”¨ shutdownNow() æ–¹æ³•ä¼šä½¿çº¿ç¨‹æ± è¿›å…¥åˆ°è¯¥çŠ¶æ€ã€‚

STOPçŠ¶æ€è¦ä¸­æ–­çº¿ç¨‹æ± ä¸­çš„æ‰€æœ‰çº¿ç¨‹ï¼Œè€Œè¿™é‡Œä½¿ç”¨Thread.interrupted()æ¥åˆ¤æ–­æ˜¯å¦ä¸­æ–­æ˜¯ä¸ºäº†ç¡®ä¿åœ¨RUNNINGæˆ–è€…SHUTDOWNçŠ¶æ€æ—¶çº¿ç¨‹æ˜¯éä¸­æ–­çŠ¶æ€çš„ï¼Œå› ä¸ºThread.interrupted()æ–¹æ³•ä¼šå¤ä½ä¸­æ–­çš„çŠ¶æ€ã€‚

æ€»ç»“ä¸€ä¸‹runWorkeræ–¹æ³•çš„æ‰§è¡Œè¿‡ç¨‹ï¼š

- whileå¾ªç¯ä¸æ–­åœ°é€šè¿‡getTask()æ–¹æ³•è·å–ä»»åŠ¡ï¼›
- getTask()æ–¹æ³•ä»é˜»å¡é˜Ÿåˆ—ä¸­å–ä»»åŠ¡ï¼›
- å¦‚æœçº¿ç¨‹æ± æ­£åœ¨åœæ­¢ï¼Œé‚£ä¹ˆè¦ä¿è¯å½“å‰çº¿ç¨‹æ˜¯ä¸­æ–­çŠ¶æ€ï¼Œå¦åˆ™è¦ä¿è¯å½“å‰çº¿ç¨‹ä¸æ˜¯ä¸­æ–­çŠ¶æ€ï¼›
- è°ƒç”¨task.run()æ‰§è¡Œä»»åŠ¡ï¼›
- å¦‚æœtaskä¸ºnullåˆ™è·³å‡ºå¾ªç¯ï¼Œæ‰§è¡ŒprocessWorkerExit()æ–¹æ³•ï¼›
- runWorkeræ–¹æ³•æ‰§è¡Œå®Œæ¯•ï¼Œä¹Ÿä»£è¡¨ç€Workerä¸­çš„runæ–¹æ³•æ‰§è¡Œå®Œæ¯•ï¼Œé”€æ¯çº¿ç¨‹ã€‚
- è¿™é‡Œçš„beforeExecuteæ–¹æ³•å’ŒafterExecuteæ–¹æ³•åœ¨ThreadPoolExecutorç±»ä¸­æ˜¯ç©ºçš„ï¼Œç•™ç»™å­ç±»æ¥å®ç°ã€‚

completedAbruptlyå˜é‡æ¥è¡¨ç¤ºåœ¨æ‰§è¡Œä»»åŠ¡è¿‡ç¨‹ä¸­æ˜¯å¦å‡ºç°äº†å¼‚å¸¸ï¼Œåœ¨processWorkerExitæ–¹æ³•ä¸­ä¼šå¯¹è¯¥å˜é‡çš„å€¼è¿›è¡Œåˆ¤æ–­ã€‚

### getTaskæ–¹æ³•å®ç°
getTaskæ–¹æ³•ç”¨æ¥ä»é˜»å¡é˜Ÿåˆ—ä¸­å–ä»»åŠ¡ï¼Œä»£ç å¦‚ä¸‹ï¼š
```java
    /**
     * Performs blocking or timed wait for a task, depending on
     * current configuration settings, or returns null if this worker
     * must exit because of any of:
     * 1. There are more than maximumPoolSize workers (due to
     *    a call to setMaximumPoolSize).
     * 2. The pool is stopped.
     * 3. The pool is shutdown and the queue is empty.
     * 4. This worker timed out waiting for a task, and timed-out
     *    workers are subject to termination (that is,
     *    {@code allowCoreThreadTimeOut || workerCount > corePoolSize})
     *    both before and after the timed wait, and if the queue is
     *    non-empty, this worker is not the last thread in the pool.
     *
     * @return task, or null if the worker must exit, in which case
     *         workerCount is decremented
     */
    private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
	        /*
	         * å¦‚æœçº¿ç¨‹æ± çŠ¶æ€rs >= SHUTDOWNï¼Œä¹Ÿå°±æ˜¯éRUNNINGçŠ¶æ€ï¼Œå†è¿›è¡Œä»¥ä¸‹åˆ¤æ–­ï¼š
	         * 1. rs >= STOPï¼Œçº¿ç¨‹æ± æ˜¯å¦æ­£åœ¨stopï¼›
	         * 2. é˜»å¡é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºã€‚
	         * å¦‚æœä»¥ä¸Šæ¡ä»¶æ»¡è¶³ï¼Œåˆ™å°†workerCountå‡1å¹¶è¿”å›nullã€‚
	         * å› ä¸ºå¦‚æœå½“å‰çº¿ç¨‹æ± çŠ¶æ€çš„å€¼æ˜¯SHUTDOWNæˆ–ä»¥ä¸Šæ—¶ï¼Œä¸å…è®¸å†å‘é˜»å¡é˜Ÿåˆ—ä¸­æ·»åŠ ä»»åŠ¡ã€‚
	         */
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            /* 
             * timedå˜é‡ç”¨äºåˆ¤æ–­æ˜¯å¦éœ€è¦è¿›è¡Œè¶…æ—¶æ§åˆ¶ã€‚
             * allowCoreThreadTimeOuté»˜è®¤æ˜¯falseï¼Œä¹Ÿå°±æ˜¯æ ¸å¿ƒçº¿ç¨‹ä¸å…è®¸è¿›è¡Œè¶…æ—¶ï¼›
             * wc > corePoolSizeï¼Œè¡¨ç¤ºå½“å‰çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡å¤§äºæ ¸å¿ƒçº¿ç¨‹æ•°é‡ï¼›
             * å¯¹äºè¶…è¿‡æ ¸å¿ƒçº¿ç¨‹æ•°é‡çš„è¿™äº›çº¿ç¨‹ï¼Œéœ€è¦è¿›è¡Œè¶…æ—¶æ§åˆ¶
             */
            // Are workers subject to culling?
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                /*
                 * wc > maximumPoolSizeçš„æƒ…å†µæ˜¯å› ä¸ºå¯èƒ½åœ¨æ­¤æ–¹æ³•æ‰§è¡Œé˜¶æ®µåŒæ—¶æ‰§è¡Œäº†setMaximumPoolSizeæ–¹æ³•ï¼›
                 * timed && timedOut å¦‚æœä¸ºtrueï¼Œè¡¨ç¤ºå½“å‰æ“ä½œéœ€è¦è¿›è¡Œè¶…æ—¶æ§åˆ¶ï¼Œå¹¶ä¸”ä¸Šæ¬¡ä»é˜»å¡é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡å‘ç”Ÿäº†è¶…æ—¶
                 * æ¥ä¸‹æ¥åˆ¤æ–­ï¼Œå¦‚æœæœ‰æ•ˆçº¿ç¨‹æ•°é‡å¤§äº1ï¼Œæˆ–è€…é˜»å¡é˜Ÿåˆ—æ˜¯ç©ºçš„ï¼Œé‚£ä¹ˆå°è¯•å°†workerCountå‡1ï¼›å¦‚æœå‡1å¤±è´¥ï¼Œåˆ™è¿”å›é‡è¯•ã€‚
                 * å¦‚æœwc == 1æ—¶ï¼Œä¹Ÿå°±è¯´æ˜å½“å‰çº¿ç¨‹æ˜¯çº¿ç¨‹æ± ä¸­å”¯ä¸€çš„ä¸€ä¸ªçº¿ç¨‹äº†ã€‚
                 * æ³¨æ„ï¼šå¦‚æœtime=falseï¼Œæ‰§è¡ŒworkQueue.takeæ–¹æ³•ï¼Œå› ä¸ºtakeæ–¹æ³•æ˜¯é˜»å¡çš„ï¼Œè¿™æ ·æ ¸å¿ƒçº¿ç¨‹æ•°å¯ä»¥ä¸é”€æ¯çš„åŸå› 
                 */
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                /*
                 * r == null, è·å–ä»»åŠ¡è¶…æ—¶ï¼Œæ ‡è®°è¶…æ—¶
                 */
                timedOut = true;
            } catch (InterruptedException retry) {
                /*
                 * å¦‚æœè·å–ä»»åŠ¡æ—¶å½“å‰çº¿ç¨‹å‘ç”Ÿäº†ä¸­æ–­ï¼Œåˆ™è®¾ç½®timedOutä¸ºfalseå¹¶è¿”å›å¾ªç¯é‡è¯•
                 */
                timedOut = false;
            }
        }
    }

```
å¦‚ä½•ä¿æŒæ ¸å¿ƒçº¿ç¨‹æ± çš„æ•°é‡?
- ç¬¬äºŒä¸ªifåˆ¤æ–­ï¼Œåœ¨æ‰§è¡Œexecuteæ–¹æ³•æ—¶ï¼Œå¦‚æœå½“å‰çº¿ç¨‹æ± çš„çº¿ç¨‹æ•°é‡è¶…è¿‡äº†corePoolSizeä¸”å°äºmaximumPoolSizeï¼Œå¹¶ä¸”workQueueå·²æ»¡æ—¶ï¼Œåˆ™å¯ä»¥å¢åŠ å·¥ä½œçº¿ç¨‹ï¼Œä½†è¿™æ—¶å¦‚æœè¶…æ—¶æ²¡æœ‰è·å–åˆ°ä»»åŠ¡ï¼Œä¹Ÿå°±æ˜¯timedOutä¸ºtrueçš„æƒ…å†µï¼Œè¯´æ˜workQueueå·²ç»ä¸ºç©ºäº†ï¼Œä¹Ÿå°±è¯´æ˜äº†å½“å‰çº¿ç¨‹æ± ä¸­ä¸éœ€è¦é‚£ä¹ˆå¤šçº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡äº†ï¼Œå¯ä»¥æŠŠå¤šäºcorePoolSizeæ•°é‡çš„çº¿ç¨‹é”€æ¯æ‰ï¼Œä¿æŒçº¿ç¨‹æ•°é‡åœ¨corePoolSizeå³å¯ã€‚
- timedå˜é‡ç”¨äºåˆ¤æ–­æ˜¯å¦éœ€è¦è¿›è¡Œè¶…æ—¶æ§åˆ¶ã€‚allowCoreThreadTimeOuté»˜è®¤æ˜¯falseï¼Œä¹Ÿå°±æ˜¯æ ¸å¿ƒçº¿ç¨‹ä¸å…è®¸è¿›è¡Œè¶…æ—¶ï¼›wc > corePoolSizeï¼Œè¡¨ç¤ºå½“å‰çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡å¤§äºæ ¸å¿ƒçº¿ç¨‹æ•°é‡ï¼›å¯¹äºè¶…è¿‡æ ¸å¿ƒçº¿ç¨‹æ•°é‡çš„è¿™äº›çº¿ç¨‹ï¼Œéœ€è¦è¿›è¡Œè¶…æ—¶æ§åˆ¶ã€‚é˜Ÿåˆ—ä¸ºç©ºäº†ï¼Œå½“å‰çº¿ç¨‹æ•°ä¸å¤§äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œé€šè¿‡takeé˜»å¡çº¿ç¨‹ï¼Œä¿æŒæ ¸å¿ƒçº¿ç¨‹æ•°æ•°é‡ã€‚

ä»€ä¹ˆæ—¶å€™é”€æ¯çº¿ç¨‹å‘¢ï¼Ÿ
- å½“ç„¶æ˜¯runWorkeræ–¹æ³•æ‰§è¡Œå®Œä¹‹åï¼Œä¹Ÿå°±æ˜¯Workerä¸­çš„runæ–¹æ³•æ‰§è¡Œå®Œï¼Œç”±JVMè‡ªåŠ¨å›æ”¶ã€‚
- getTaskæ–¹æ³•è¿”å›nullæ—¶ï¼Œåœ¨runWorkeræ–¹æ³•ä¸­ä¼šè·³å‡ºwhileå¾ªç¯ï¼Œç„¶åä¼šæ‰§è¡ŒprocessWorkerExitæ–¹æ³•ã€‚

### processWorkerExitæ–¹æ³•
```java
    /**
     * Performs cleanup and bookkeeping for a dying worker. Called
     * only from worker threads. Unless completedAbruptly is set,
     * assumes that workerCount has already been adjusted to account
     * for exit.  This method removes thread from worker set, and
     * possibly terminates the pool or replaces the worker if either
     * it exited due to user task exception or if fewer than
     * corePoolSize workers are running or queue is non-empty but
     * there are no workers.
     *
     * @param w the worker
     * @param completedAbruptly if the worker died due to user exception
     */
    private void processWorkerExit(Worker w, boolean completedAbruptly) {
        /*
         * å¦‚æœcompletedAbruptlyå€¼ä¸ºtrueï¼Œåˆ™è¯´æ˜çº¿ç¨‹æ‰§è¡Œæ—¶å‡ºç°äº†å¼‚å¸¸ï¼Œéœ€è¦å°†workerCountå‡1ï¼›
         * å¦‚æœçº¿ç¨‹æ‰§è¡Œæ—¶æ²¡æœ‰å‡ºç°å¼‚å¸¸ï¼Œè¯´æ˜åœ¨getTask()æ–¹æ³•ä¸­å·²ç»å·²ç»å¯¹workerCountè¿›è¡Œäº†å‡1æ“ä½œï¼Œè¿™é‡Œå°±ä¸å¿…å†å‡äº†ã€‚ 
         */
        if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
            decrementWorkerCount();

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            /*
             * ç»Ÿè®¡å®Œæˆçš„ä»»åŠ¡æ•°
             */
            completedTaskCount += w.completedTasks;
            workers.remove(w);
        } finally {
            mainLock.unlock();
        }

        /*
         * æ ¹æ®çº¿ç¨‹æ± çŠ¶æ€è¿›è¡Œåˆ¤æ–­æ˜¯å¦ç»“æŸçº¿ç¨‹æ± 
         */
        tryTerminate();

        /*
         * å½“çº¿ç¨‹æ± æ˜¯RUNNINGæˆ–SHUTDOWNçŠ¶æ€æ—¶ï¼Œå¦‚æœworkeræ˜¯å¼‚å¸¸ç»“æŸï¼Œé‚£ä¹ˆä¼šç›´æ¥addWorkerï¼›
         * å¦‚æœallowCoreThreadTimeOut=trueï¼Œå¹¶ä¸”ç­‰å¾…é˜Ÿåˆ—æœ‰ä»»åŠ¡ï¼Œè‡³å°‘ä¿ç•™ä¸€ä¸ªworkerï¼›
         * å¦‚æœallowCoreThreadTimeOut=falseï¼ŒworkerCountä¸å°‘äºcorePoolSizeã€‚
         */
        int c = ctl.get();
        if (runStateLessThan(c, STOP)) {
            if (!completedAbruptly) {
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
                if (min == 0 && ! workQueue.isEmpty())
                    min = 1;
                if (workerCountOf(c) >= min)
                    return; // replacement not needed
            }
            addWorker(null, false);
        }
    }

```
è‡³æ­¤ï¼ŒprocessWorkerExitæ‰§è¡Œå®Œä¹‹åï¼Œå·¥ä½œçº¿ç¨‹è¢«é”€æ¯ï¼Œä»¥ä¸Šå°±æ˜¯æ•´ä¸ªå·¥ä½œçº¿ç¨‹çš„ç”Ÿå‘½å‘¨æœŸï¼Œä»executeæ–¹æ³•å¼€å§‹ï¼ŒWorkerä½¿ç”¨ThreadFactoryåˆ›å»ºæ–°çš„å·¥ä½œçº¿ç¨‹ï¼ŒrunWorkeré€šè¿‡getTaskè·å–ä»»åŠ¡ï¼Œç„¶åæ‰§è¡Œä»»åŠ¡ï¼Œå¦‚æœgetTaskè¿”å›nullï¼Œè¿›å…¥processWorkerExitæ–¹æ³•ï¼Œæ•´ä¸ªçº¿ç¨‹ç»“æŸï¼Œå¦‚å›¾æ‰€ç¤º:
![threadpool-lifecycle](/assets/images/2019/03/java_concurrent_threadpool-lifecycle.png)

### tryTerminateæ–¹æ³•
tryTerminateæ–¹æ³•æ ¹æ®çº¿ç¨‹æ± çŠ¶æ€è¿›è¡Œåˆ¤æ–­æ˜¯å¦ç»“æŸçº¿ç¨‹æ± ï¼Œä»£ç å¦‚ä¸‹ï¼š
```java
    /**
     * Transitions to TERMINATED state if either (SHUTDOWN and pool
     * and queue empty) or (STOP and pool empty).  If otherwise
     * eligible to terminate but workerCount is nonzero, interrupts an
     * idle worker to ensure that shutdown signals propagate. This
     * method must be called following any action that might make
     * termination possible -- reducing worker count or removing tasks
     * from the queue during shutdown. The method is non-private to
     * allow access from ScheduledThreadPoolExecutor.
     */
    final void tryTerminate() {
        for (;;) {
            int c = ctl.get();
            /*
             * å½“å‰çº¿ç¨‹æ± çš„çŠ¶æ€ä¸ºä»¥ä¸‹å‡ ç§æƒ…å†µæ—¶ï¼Œç›´æ¥è¿”å›ï¼š
             * 1. RUNNINGï¼Œå› ä¸ºè¿˜åœ¨è¿è¡Œä¸­ï¼Œä¸èƒ½åœæ­¢ï¼›
             * 2. TIDYINGæˆ–TERMINATEDï¼Œå› ä¸ºçº¿ç¨‹æ± ä¸­å·²ç»æ²¡æœ‰æ­£åœ¨è¿è¡Œçš„çº¿ç¨‹äº†ï¼›
             * 3. SHUTDOWNå¹¶ä¸”ç­‰å¾…é˜Ÿåˆ—éç©ºï¼Œè¿™æ—¶è¦æ‰§è¡Œå®ŒworkQueueä¸­çš„taskï¼›
             */
            if (isRunning(c) ||
                runStateAtLeast(c, TIDYING) ||
                (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))
                return;
            /*
             * å¦‚æœçº¿ç¨‹æ•°é‡ä¸ä¸º0ï¼Œåˆ™ä¸­æ–­ä¸€ä¸ªç©ºé—²çš„å·¥ä½œçº¿ç¨‹ï¼Œå¹¶è¿”å›
             */
            if (workerCountOf(c) != 0) { // Eligible to terminate
                interruptIdleWorkers(ONLY_ONE);
                return;
            }

            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                /*
                 * è¿™é‡Œå°è¯•è®¾ç½®çŠ¶æ€ä¸ºTIDYINGï¼Œå¦‚æœè®¾ç½®æˆåŠŸï¼Œåˆ™è°ƒç”¨terminatedæ–¹æ³•
                 */
                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                    try {
                        /*
                         * terminatedæ–¹æ³•é»˜è®¤ä»€ä¹ˆéƒ½ä¸åšï¼Œç•™ç»™å­ç±»å®ç°
                         */
                        terminated();
                    } finally {
                        /*
                         * è®¾ç½®çŠ¶æ€ä¸ºTERMINATED
                         */
                        ctl.set(ctlOf(TERMINATED, 0));
                        termination.signalAll();
                    }
                    return;
                }
            } finally {
                mainLock.unlock();
            }
            // else retry on failed CAS
        }
    }
```
interruptIdleWorkers(ONLY_ONE);çš„ä½œç”¨æ˜¯å› ä¸ºåœ¨getTaskæ–¹æ³•ä¸­æ‰§è¡ŒworkQueue.take()æ—¶ï¼Œå¦‚æœä¸æ‰§è¡Œä¸­æ–­ä¼šä¸€ç›´é˜»å¡ã€‚åœ¨ä¸‹é¢ä»‹ç»çš„shutdownæ–¹æ³•ä¸­ï¼Œä¼šä¸­æ–­æ‰€æœ‰ç©ºé—²çš„å·¥ä½œçº¿ç¨‹ï¼Œå¦‚æœåœ¨æ‰§è¡Œshutdownæ—¶å·¥ä½œçº¿ç¨‹æ²¡æœ‰ç©ºé—²ï¼Œç„¶ååˆå»è°ƒç”¨äº†getTaskæ–¹æ³•ï¼Œè¿™æ—¶å¦‚æœworkQueueä¸­æ²¡æœ‰ä»»åŠ¡äº†ï¼Œè°ƒç”¨workQueue.take()æ—¶å°±ä¼šä¸€ç›´é˜»å¡ã€‚æ‰€ä»¥æ¯æ¬¡åœ¨å·¥ä½œçº¿ç¨‹ç»“æŸæ—¶è°ƒç”¨tryTerminateæ–¹æ³•æ¥å°è¯•ä¸­æ–­ä¸€ä¸ªç©ºé—²å·¥ä½œçº¿ç¨‹ï¼Œé¿å…åœ¨é˜Ÿåˆ—ä¸ºç©ºæ—¶å–ä»»åŠ¡ä¸€ç›´é˜»å¡çš„æƒ…å†µã€‚

### shutdownæ–¹æ³•
shutdownæ–¹æ³•è¦å°†çº¿ç¨‹æ± åˆ‡æ¢åˆ°SHUTDOWNçŠ¶æ€ï¼Œå¹¶è°ƒç”¨interruptIdleWorkersæ–¹æ³•è¯·æ±‚ä¸­æ–­æ‰€æœ‰ç©ºé—²çš„workerï¼Œæœ€åè°ƒç”¨tryTerminateå°è¯•ç»“æŸçº¿ç¨‹æ± ã€‚
```java
    /**
     * Initiates an orderly shutdown in which previously submitted
     * tasks are executed, but no new tasks will be accepted.
     * Invocation has no additional effect if already shut down.
     *
     * <p>This method does not wait for previously submitted tasks to
     * complete execution.  Use {@link #awaitTermination awaitTermination}
     * to do that.
     *
     * @throws SecurityException {@inheritDoc}
     */
    public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            /*
             * å®‰å…¨ç­–ç•¥åˆ¤æ–­
             */
            checkShutdownAccess();
            /*
             * åˆ‡æ¢çŠ¶æ€ä¸ºSHUTDOWN
             */ 
            advanceRunState(SHUTDOWN);
            /*
             * ä¸­æ–­ç©ºé—²çº¿ç¨‹
             */
            interruptIdleWorkers();
            onShutdown(); // hook for ScheduledThreadPoolExecutor
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
    }

```
ä¸‹é¢æ˜¯[æ·±å…¥ç†è§£Javaçº¿ç¨‹æ± ](http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/)ä¸­çš„é—®é¢˜æ¢ç©¶ï¼Œéå¸¸æ·±å…¥ï¼Œç»†èŠ‚éå¸¸åˆ°ä½ï¼ŒğŸ‘

è¿™é‡Œæ€è€ƒä¸€ä¸ªé—®é¢˜ï¼šåœ¨runWorkeræ–¹æ³•ä¸­ï¼Œæ‰§è¡Œä»»åŠ¡æ—¶å¯¹Workerå¯¹è±¡wè¿›è¡Œäº†lockæ“ä½œï¼Œä¸ºä»€ä¹ˆè¦åœ¨æ‰§è¡Œä»»åŠ¡çš„æ—¶å€™å¯¹æ¯ä¸ªå·¥ä½œçº¿ç¨‹éƒ½åŠ é”å‘¢ï¼Ÿåˆ†æè¿‡ç¨‹ï¼š
- åœ¨getTaskæ–¹æ³•ä¸­ï¼Œå¦‚æœè¿™æ—¶çº¿ç¨‹æ± çš„çŠ¶æ€æ˜¯SHUTDOWNå¹¶ä¸”workQueueä¸ºç©ºï¼Œé‚£ä¹ˆå°±åº”è¯¥è¿”å›nullæ¥ç»“æŸè¿™ä¸ªå·¥ä½œçº¿ç¨‹ï¼Œè€Œä½¿çº¿ç¨‹æ± è¿›å…¥SHUTDOWNçŠ¶æ€éœ€è¦è°ƒç”¨shutdownæ–¹æ³•ï¼›
- shutdownæ–¹æ³•ä¼šè°ƒç”¨interruptIdleWorkersæ¥ä¸­æ–­ç©ºé—²çš„çº¿ç¨‹ï¼ŒinterruptIdleWorkersæŒæœ‰mainLockï¼Œä¼šéå†workersæ¥é€ä¸ªåˆ¤æ–­å·¥ä½œçº¿ç¨‹æ˜¯å¦ç©ºé—²ã€‚ä½†getTaskæ–¹æ³•ä¸­æ²¡æœ‰mainLockï¼›
- åœ¨getTaskä¸­ï¼Œå¦‚æœåˆ¤æ–­å½“å‰çº¿ç¨‹æ± çŠ¶æ€æ˜¯RUNNINGï¼Œå¹¶ä¸”é˜»å¡é˜Ÿåˆ—ä¸ºç©ºï¼Œé‚£ä¹ˆä¼šè°ƒç”¨workQueue.take()è¿›è¡Œé˜»å¡ï¼›
- å¦‚æœåœ¨åˆ¤æ–­å½“å‰çº¿ç¨‹æ± çŠ¶æ€æ˜¯RUNNINGåï¼Œè¿™æ—¶è°ƒç”¨äº†shutdownæ–¹æ³•æŠŠçŠ¶æ€æ”¹ä¸ºäº†SHUTDOWNï¼Œè¿™æ—¶å¦‚æœä¸è¿›è¡Œä¸­æ–­ï¼Œé‚£ä¹ˆå½“å‰çš„å·¥ä½œçº¿ç¨‹åœ¨è°ƒç”¨äº†workQueue.take()åä¼šä¸€ç›´é˜»å¡è€Œä¸ä¼šè¢«é”€æ¯ï¼Œå› ä¸ºåœ¨SHUTDOWNçŠ¶æ€ä¸‹ä¸å…è®¸å†æœ‰æ–°çš„ä»»åŠ¡æ·»åŠ åˆ°workQueueä¸­ï¼Œè¿™æ ·ä¸€æ¥çº¿ç¨‹æ± æ°¸è¿œéƒ½å…³é—­ä¸äº†äº†ï¼›
- ç”±ä¸Šå¯çŸ¥ï¼Œshutdownæ–¹æ³•ä¸getTaskæ–¹æ³•ï¼ˆä»é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡æ—¶ï¼‰å­˜åœ¨ç«æ€æ¡ä»¶ï¼›
- è§£å†³è¿™ä¸€é—®é¢˜å°±éœ€è¦ç”¨åˆ°çº¿ç¨‹çš„ä¸­æ–­ï¼Œä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆè¦ç”¨interruptIdleWorkersæ–¹æ³•ã€‚åœ¨è°ƒç”¨workQueue.take()æ—¶ï¼Œå¦‚æœå‘ç°å½“å‰çº¿ç¨‹åœ¨æ‰§è¡Œä¹‹å‰æˆ–è€…æ‰§è¡ŒæœŸé—´æ˜¯ä¸­æ–­çŠ¶æ€ï¼Œåˆ™ä¼šæŠ›å‡ºInterruptedExceptionï¼Œè§£é™¤é˜»å¡çš„çŠ¶æ€ï¼›
- ä½†æ˜¯è¦ä¸­æ–­å·¥ä½œçº¿ç¨‹ï¼Œè¿˜è¦åˆ¤æ–­å·¥ä½œçº¿ç¨‹æ˜¯å¦æ˜¯ç©ºé—²çš„ï¼Œå¦‚æœå·¥ä½œçº¿ç¨‹æ­£åœ¨å¤„ç†ä»»åŠ¡ï¼Œå°±ä¸åº”è¯¥å‘ç”Ÿä¸­æ–­ï¼›
- æ‰€ä»¥Workerç»§æ‰¿è‡ªAQSï¼Œåœ¨å·¥ä½œçº¿ç¨‹å¤„ç†ä»»åŠ¡æ—¶ä¼šè¿›è¡Œlockï¼ŒinterruptIdleWorkersåœ¨è¿›è¡Œä¸­æ–­æ—¶ä¼šä½¿ç”¨tryLockæ¥åˆ¤æ–­è¯¥å·¥ä½œçº¿ç¨‹æ˜¯å¦æ­£åœ¨å¤„ç†ä»»åŠ¡ï¼Œå¦‚æœtryLockè¿”å›trueï¼Œè¯´æ˜è¯¥å·¥ä½œçº¿ç¨‹å½“å‰æœªæ‰§è¡Œä»»åŠ¡ï¼Œè¿™æ—¶æ‰å¯ä»¥è¢«ä¸­æ–­ã€‚

ä¸‹é¢å°±æ¥åˆ†æä¸€ä¸‹interruptIdleWorkersæ–¹æ³•ã€‚
### interruptIdleWorkersæ–¹æ³•
```java
    /**
     * Common form of interruptIdleWorkers, to avoid having to
     * remember what the boolean argument means.
     */
    private void interruptIdleWorkers() {
        interruptIdleWorkers(false);
    }

    /**
     * Interrupts threads that might be waiting for tasks (as
     * indicated by not being locked) so they can check for
     * termination or configuration changes. Ignores
     * SecurityExceptions (in which case some threads may remain
     * uninterrupted).
     *
     * @param onlyOne If true, interrupt at most one worker. This is
     * called only from tryTerminate when termination is otherwise
     * enabled but there are still other workers.  In this case, at
     * most one waiting worker is interrupted to propagate shutdown
     * signals in case all threads are currently waiting.
     * Interrupting any arbitrary thread ensures that newly arriving
     * workers since shutdown began will also eventually exit.
     * To guarantee eventual termination, it suffices to always
     * interrupt only one idle worker, but shutdown() interrupts all
     * idle workers so that redundant workers exit promptly, not
     * waiting for a straggler task to finish.
     */
    private void interruptIdleWorkers(boolean onlyOne) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            for (Worker w : workers) {
                Thread t = w.thread;
                if (!t.isInterrupted() && w.tryLock()) {
                    try {
                        t.interrupt();
                    } catch (SecurityException ignore) {
                    } finally {
                        w.unlock();
                    }
                }
                if (onlyOne)
                    break;
            }
        } finally {
            mainLock.unlock();
        }
    }

```
interruptIdleWorkerséå†workersä¸­æ‰€æœ‰çš„å·¥ä½œçº¿ç¨‹ï¼Œè‹¥çº¿ç¨‹æ²¡æœ‰è¢«ä¸­æ–­tryLockæˆåŠŸï¼Œå°±ä¸­æ–­è¯¥çº¿ç¨‹ã€‚

ä¸ºä»€ä¹ˆéœ€è¦æŒæœ‰mainLockï¼Ÿå› ä¸ºworkersæ˜¯HashSetç±»å‹çš„ï¼Œä¸èƒ½ä¿è¯çº¿ç¨‹å®‰å…¨ã€‚

### shutdownNowæ–¹æ³•
```java
    /**
     * Attempts to stop all actively executing tasks, halts the
     * processing of waiting tasks, and returns a list of the tasks
     * that were awaiting execution. These tasks are drained (removed)
     * from the task queue upon return from this method.
     *
     * <p>This method does not wait for actively executing tasks to
     * terminate.  Use {@link #awaitTermination awaitTermination} to
     * do that.
     *
     * <p>There are no guarantees beyond best-effort attempts to stop
     * processing actively executing tasks.  This implementation
     * cancels tasks via {@link Thread#interrupt}, so any task that
     * fails to respond to interrupts may never terminate.
     *
     * @throws SecurityException {@inheritDoc}
     */
    public List<Runnable> shutdownNow() {
        List<Runnable> tasks;
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            checkShutdownAccess();
            advanceRunState(STOP);
            /*
             * ä¸­æ–­æ‰€æœ‰å·¥ä½œçº¿ç¨‹ï¼Œæ— è®ºæ˜¯å¦ç©ºé—²
             */
            interruptWorkers();
            /*
             * å–å‡ºé˜Ÿåˆ—ä¸­æ²¡æœ‰è¢«æ‰§è¡Œçš„ä»»åŠ¡
             */
            tasks = drainQueue();
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
        return tasks;
    }
```
shutdownNowæ–¹æ³•ä¸shutdownæ–¹æ³•ç±»ä¼¼ï¼Œä¸åŒçš„åœ°æ–¹åœ¨äºï¼š
- è®¾ç½®çŠ¶æ€ä¸ºSTOPï¼›
- ä¸­æ–­æ‰€æœ‰å·¥ä½œçº¿ç¨‹ï¼Œæ— è®ºæ˜¯å¦æ˜¯ç©ºé—²çš„ï¼›
- å–å‡ºé˜»å¡é˜Ÿåˆ—ä¸­æ²¡æœ‰è¢«æ‰§è¡Œçš„ä»»åŠ¡å¹¶è¿”å›ã€‚
shutdownNowæ–¹æ³•æ‰§è¡Œå®Œä¹‹åè°ƒç”¨tryTerminateæ–¹æ³•ï¼Œè¯¥æ–¹æ³•åœ¨ä¸Šæ–‡å·²ç»åˆ†æè¿‡äº†ï¼Œç›®çš„å°±æ˜¯ä½¿çº¿ç¨‹æ± çš„çŠ¶æ€è®¾ç½®ä¸ºTERMINATEDã€‚

## æ€ä¹ˆåˆ›å»ºçº¿ç¨‹æ± 
### Executors
- newSingleThreadExecutor
åˆ›å»ºä¸€ä¸ªçº¿ç¨‹çš„çº¿ç¨‹æ± ï¼Œåœ¨è¿™ä¸ªçº¿ç¨‹æ± ä¸­å§‹ç»ˆåªæœ‰ä¸€ä¸ªçº¿ç¨‹å­˜åœ¨ã€‚å¦‚æœçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹å› ä¸ºå¼‚å¸¸é—®é¢˜é€€å‡ºï¼Œé‚£ä¹ˆä¼šæœ‰ä¸€ä¸ªæ–°çš„çº¿ç¨‹æ¥æ›¿ä»£å®ƒã€‚æ­¤çº¿ç¨‹æ± ä¿è¯æ‰€æœ‰ä»»åŠ¡çš„æ‰§è¡Œé¡ºåºæŒ‰ç…§ä»»åŠ¡çš„æäº¤é¡ºåºæ‰§è¡Œã€‚

- newFixedThreadPool
åˆ›å»ºå›ºå®šå¤§å°çš„çº¿ç¨‹æ± ã€‚æ¯æ¬¡æäº¤ä¸€ä¸ªä»»åŠ¡å°±åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œç›´åˆ°çº¿ç¨‹è¾¾åˆ°çº¿ç¨‹æ± çš„æœ€å¤§å¤§å°ã€‚çº¿ç¨‹æ± çš„å¤§å°ä¸€æ—¦è¾¾åˆ°æœ€å¤§å€¼å°±ä¼šä¿æŒä¸å˜ï¼Œå¦‚æœæŸä¸ªçº¿ç¨‹å› ä¸ºæ‰§è¡Œå¼‚å¸¸è€Œç»“æŸï¼Œé‚£ä¹ˆçº¿ç¨‹æ± ä¼šè¡¥å……ä¸€ä¸ªæ–°çº¿ç¨‹ã€‚

- newCachedThreadPool
å¯æ ¹æ®å®é™…æƒ…å†µï¼Œè°ƒæ•´çº¿ç¨‹æ•°é‡çš„çº¿ç¨‹æ± ï¼Œçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡ä¸ç¡®å®šï¼Œå¦‚æœæœ‰ç©ºé—²çº¿ç¨‹ä¼šä¼˜å…ˆé€‰æ‹©ç©ºé—²çº¿ç¨‹ï¼Œå¦‚æœæ²¡æœ‰ç©ºé—²çº¿ç¨‹å¹¶ä¸”æ­¤æ—¶æœ‰ä»»åŠ¡æäº¤ä¼šåˆ›å»ºæ–°çš„çº¿ç¨‹ã€‚åœ¨æ­£å¸¸å¼€å‘ä¸­å¹¶ä¸æ¨èè¿™ä¸ªçº¿ç¨‹æ± ï¼Œå› ä¸ºåœ¨æç«¯æƒ…å†µä¸‹ï¼Œä¼šå› ä¸º newCachedThreadPool åˆ›å»ºè¿‡å¤šçº¿ç¨‹è€Œè€—å°½ CPU å’Œå†…å­˜èµ„æºã€‚

- newScheduledThreadPool
æ­¤çº¿ç¨‹æ± å¯ä»¥æŒ‡å®šå›ºå®šæ•°é‡çš„çº¿ç¨‹æ¥å‘¨æœŸæ€§çš„å»æ‰§è¡Œã€‚æ¯”å¦‚é€šè¿‡ scheduleAtFixedRate æˆ–è€… scheduleWithFixedDelay æ¥æŒ‡å®šå‘¨æœŸæ—¶é—´ã€‚

å¦å¤–åœ¨å†™å®šæ—¶ä»»åŠ¡æ—¶ï¼ˆå¦‚æœä¸ç”¨ Quartz æ¡†æ¶ï¼‰ï¼Œæœ€å¥½é‡‡ç”¨è¿™ç§çº¿ç¨‹æ± æ¥åšï¼Œå› ä¸ºå®ƒå¯ä»¥ä¿è¯é‡Œé¢å§‹ç»ˆæ˜¯å­˜åœ¨æ´»çš„çº¿ç¨‹çš„ã€‚

### æ¨èä½¿ç”¨ ThreadPoolExecutor æ–¹å¼
åœ¨é˜¿é‡Œçš„ Java å¼€å‘æ‰‹å†Œæ—¶æœ‰ä¸€æ¡æ˜¯ä¸æ¨èä½¿ç”¨ Executors å»åˆ›å»ºï¼Œè€Œæ˜¯æ¨èå»ä½¿ç”¨ ThreadPoolExecutor æ¥åˆ›å»ºçº¿ç¨‹æ± ã€‚

è¿™æ ·åšçš„ç›®çš„ä¸»è¦åŸå› æ˜¯ï¼šä½¿ç”¨ Executors åˆ›å»ºçº¿ç¨‹æ± ä¸ä¼šä¼ å…¥æ ¸å¿ƒå‚æ•°ï¼Œè€Œæ˜¯é‡‡ç”¨çš„é»˜è®¤å€¼ï¼Œè¿™æ ·çš„è¯æˆ‘ä»¬å¾€å¾€ä¼šå¿½ç•¥æ‰é‡Œé¢å‚æ•°çš„å«ä¹‰ï¼Œå¦‚æœä¸šåŠ¡åœºæ™¯è¦æ±‚æ¯”è¾ƒè‹›åˆ»çš„è¯ï¼Œå­˜åœ¨èµ„æºè€—å°½çš„é£é™©ï¼›å¦å¤–é‡‡ç”¨ ThreadPoolExecutor çš„æ–¹å¼å¯ä»¥è®©æˆ‘ä»¬æ›´åŠ æ¸…æ¥šåœ°äº†è§£çº¿ç¨‹æ± çš„è¿è¡Œè§„åˆ™ï¼Œä¸ç®¡æ˜¯é¢è¯•è¿˜æ˜¯å¯¹æŠ€æœ¯æˆé•¿éƒ½æœ‰è«å¤§çš„å¥½å¤„ã€‚

æ”¹äº†å˜é‡ï¼Œå…¶ä»–çº¿ç¨‹å¯ä»¥ç«‹å³çŸ¥é“ã€‚ä¿è¯å¯è§æ€§çš„æ–¹æ³•æœ‰ä»¥ä¸‹å‡ ç§ï¼š

volatile
åŠ å…¥ volatile å…³é”®å­—çš„å˜é‡åœ¨è¿›è¡Œæ±‡ç¼–æ—¶ä¼šå¤šå‡ºä¸€ä¸ª lock å‰ç¼€æŒ‡ä»¤ï¼Œè¿™ä¸ªå‰ç¼€æŒ‡ä»¤ç›¸å½“äºä¸€ä¸ªå†…å­˜å±éšœï¼Œå†…å­˜å±éšœå¯ä»¥ä¿è¯å†…å­˜æ“ä½œçš„é¡ºåºã€‚å½“å£°æ˜ä¸º volatile çš„å˜é‡è¿›è¡Œå†™æ“ä½œæ—¶ï¼Œé‚£ä¹ˆè¿™ä¸ªå˜é‡éœ€è¦å°†æ•°æ®å†™åˆ°ä¸»å†…å­˜ä¸­ã€‚

ç”±äºå¤„ç†å™¨ä¼šå®ç°ç¼“å­˜ä¸€è‡´æ€§åè®®ï¼Œæ‰€ä»¥å†™åˆ°ä¸»å†…å­˜åä¼šå¯¼è‡´å…¶ä»–å¤„ç†å™¨çš„ç¼“å­˜æ— æ•ˆï¼Œä¹Ÿå°±æ˜¯çº¿ç¨‹å·¥ä½œå†…å­˜æ— æ•ˆï¼Œéœ€è¦ä»ä¸»å†…å­˜ä¸­é‡æ–°åˆ·æ–°æ•°æ®ã€‚

## çº¿ç¨‹æ± ç›‘æ§
çº¿ç¨‹æ± çš„ç›‘æ§
é€šè¿‡çº¿ç¨‹æ± æä¾›çš„å‚æ•°è¿›è¡Œç›‘æ§ã€‚çº¿ç¨‹æ± é‡Œæœ‰ä¸€äº›å±æ€§åœ¨ç›‘æ§çº¿ç¨‹æ± çš„æ—¶å€™å¯ä»¥ä½¿ç”¨

- getTaskCountï¼šçº¿ç¨‹æ± å·²ç»æ‰§è¡Œçš„å’Œæœªæ‰§è¡Œçš„ä»»åŠ¡æ€»æ•°ï¼›
- getCompletedTaskCountï¼šçº¿ç¨‹æ± å·²å®Œæˆçš„ä»»åŠ¡æ•°é‡ï¼Œè¯¥å€¼å°äºç­‰äºtaskCountï¼›
- getLargestPoolSizeï¼šçº¿ç¨‹æ± æ›¾ç»åˆ›å»ºè¿‡çš„æœ€å¤§çº¿ç¨‹æ•°é‡ã€‚é€šè¿‡è¿™ä¸ªæ•°æ®å¯ä»¥çŸ¥é“çº¿ç¨‹æ± æ˜¯å¦æ»¡è¿‡ï¼Œä¹Ÿå°±æ˜¯è¾¾åˆ°äº†maximumPoolSizeï¼›
- getPoolSizeï¼šçº¿ç¨‹æ± å½“å‰çš„çº¿ç¨‹æ•°é‡ï¼›
- getActiveCountï¼šå½“å‰çº¿ç¨‹æ± ä¸­æ­£åœ¨æ‰§è¡Œä»»åŠ¡çš„çº¿ç¨‹æ•°é‡ã€‚
é€šè¿‡è¿™äº›æ–¹æ³•ï¼Œå¯ä»¥å¯¹çº¿ç¨‹æ± è¿›è¡Œç›‘æ§ï¼Œåœ¨ThreadPoolExecutorç±»ä¸­æä¾›äº†å‡ ä¸ªç©ºæ–¹æ³•ï¼Œå¦‚beforeExecuteæ–¹æ³•ï¼ŒafterExecuteæ–¹æ³•å’Œterminatedæ–¹æ³•ï¼Œå¯ä»¥æ‰©å±•è¿™äº›æ–¹æ³•åœ¨æ‰§è¡Œå‰æˆ–æ‰§è¡Œåå¢åŠ ä¸€äº›æ–°çš„æ“ä½œï¼Œä¾‹å¦‚ç»Ÿè®¡çº¿ç¨‹æ± çš„æ‰§è¡Œä»»åŠ¡çš„æ—¶é—´ç­‰ï¼Œå¯ä»¥ç»§æ‰¿è‡ªThreadPoolExecutoræ¥è¿›è¡Œæ‰©å±•ã€‚



## æ€»ç»“
æœ¬æ–‡æ¯”è¾ƒè¯¦ç»†çš„åˆ†æäº†çº¿ç¨‹æ± çš„å·¥ä½œæµç¨‹ï¼Œæ€»ä½“æ¥è¯´æœ‰å¦‚ä¸‹å‡ ä¸ªå†…å®¹ï¼š

- åˆ†æäº†çº¿ç¨‹çš„åˆ›å»ºï¼Œä»»åŠ¡çš„æäº¤ï¼ŒçŠ¶æ€çš„è½¬æ¢ä»¥åŠçº¿ç¨‹æ± çš„å…³é—­ï¼›
- è¿™é‡Œé€šè¿‡executeæ–¹æ³•æ¥å±•å¼€çº¿ç¨‹æ± çš„å·¥ä½œæµç¨‹ï¼Œexecuteæ–¹æ³•é€šè¿‡corePoolSizeï¼ŒmaximumPoolSizeä»¥åŠé˜»å¡é˜Ÿåˆ—çš„å¤§å°æ¥åˆ¤æ–­å†³å®šä¼ å…¥çš„ä»»åŠ¡åº”è¯¥è¢«ç«‹å³æ‰§è¡Œï¼Œè¿˜æ˜¯åº”è¯¥æ·»åŠ åˆ°é˜»å¡é˜Ÿåˆ—ä¸­ï¼Œè¿˜æ˜¯åº”è¯¥æ‹’ç»ä»»åŠ¡ã€‚
- ä»‹ç»äº†çº¿ç¨‹æ± å…³é—­æ—¶çš„è¿‡ç¨‹ï¼Œä¹Ÿåˆ†æäº†shutdownæ–¹æ³•ä¸getTaskæ–¹æ³•å­˜åœ¨ç«æ€æ¡ä»¶ï¼›
- åœ¨è·å–ä»»åŠ¡æ—¶ï¼Œè¦é€šè¿‡çº¿ç¨‹æ± çš„çŠ¶æ€æ¥åˆ¤æ–­åº”è¯¥ç»“æŸå·¥ä½œçº¿ç¨‹è¿˜æ˜¯é˜»å¡çº¿ç¨‹ç­‰å¾…æ–°çš„ä»»åŠ¡ï¼Œä¹Ÿè§£é‡Šäº†ä¸ºä»€ä¹ˆå…³é—­çº¿ç¨‹æ± æ—¶è¦ä¸­æ–­å·¥ä½œçº¿ç¨‹ä»¥åŠä¸ºä»€ä¹ˆæ¯ä¸€ä¸ªworkeréƒ½éœ€è¦lockã€‚


Q1:ä¸ºä»€ä¹ˆè¦ç”¨çº¿ç¨‹æ± ï¼Œæœ‰å“ªäº›ä¼˜ç‚¹ï¼Ÿ
- é™ä½èµ„æºæ¶ˆè€—ã€‚é€šè¿‡é‡å¤åˆ©ç”¨å·²åˆ›å»ºçš„çº¿ç¨‹é™ä½çº¿ç¨‹åˆ›å»ºå’Œé”€æ¯é€ æˆçš„æ¶ˆè€—ã€‚ 
- æé«˜å“åº”é€Ÿåº¦ã€‚å½“ä»»åŠ¡åˆ°è¾¾æ—¶ï¼Œä»»åŠ¡å¯ä»¥ä¸éœ€è¦ç­‰åˆ°çº¿ç¨‹åˆ›å»ºå°±èƒ½ç«‹å³æ‰§è¡Œã€‚ 
- æé«˜çº¿ç¨‹çš„å¯ç®¡ç†æ€§

Q2:æ ¸å¿ƒçº¿ç¨‹æ˜¯å¦‚ä½•ä¸€ç›´ä¿æŒçš„ï¼Ÿèƒ½å¦è®©æ ¸å¿ƒçº¿ç¨‹é”€æ¯å‘¢ï¼Ÿ
getTaskæ–¹æ³•ä¸­
```java
    //ä»é˜»å¡ä»»åŠ¡é˜Ÿåˆ—ä¸­å–ä»»åŠ¡ï¼Œå¦‚æœè®¾ç½®äº†allowCoreThreadTimeOut(true)
    // æˆ–è€…
    // å½“å‰è¿è¡Œçš„ä»»åŠ¡æ•°å¤§äºè®¾ç½®çš„æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œé‚£ä¹ˆtimed =true
    boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

    //æ ¹æ® timed true æˆ– false æ¥åˆ¤æ–­ä»å“ªé‡Œå–ä»»åŠ¡ï¼Œæ˜¯å¦è¶…æ—¶å–ä»»åŠ¡
    Runnable r = timed ?
            workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
            // take()ä¼šä¸€ç›´é˜»å¡ï¼Œç­‰å¾…ä»»åŠ¡çš„æ·»åŠ ã€‚
            workQueue.take();
```
å¦‚æœå½“å‰çº¿ç¨‹æ•°å°äºæˆ–è€…ç­‰äºæ ¸å¿ƒçº¿ç¨‹æ•°ï¼ˆallowCoreThreadTimeOuté»˜è®¤falseï¼‰,åˆ™timedä¸ºfalseã€‚
timedä¸ºfalseè¡¨ç¤ºå–ä»»åŠ¡ä¸è¶…æ—¶ï¼ˆé˜»å¡å»ä»»åŠ¡ï¼‰ï¼Œè°ƒç”¨workQueue.takeæ‰§è¡Œ
è®¾ç½®allowCoreThreadTimeOut(true) å°±èƒ½ä½¿æ ¸å¿ƒçº¿ç¨‹é”€æ¯çš„å‘¢ï¼Œå‰ææ˜¯å¿…é¡»è®¾ç½®setKeepAliveTimeï¼Œå¦åˆ™çº¿ç¨‹è¶…æ—¶æ—¶é—´æ²¡æœ‰ï¼Œæ— æ³•è®¾ç½®

```java
    /**
     * Sets the policy governing whether core threads may time out and
     * terminate if no tasks arrive within the keep-alive time, being
     * replaced if needed when new tasks arrive. When false, core
     * threads are never terminated due to lack of incoming
     * tasks. When true, the same keep-alive policy applying to
     * non-core threads applies also to core threads. To avoid
     * continual thread replacement, the keep-alive time must be
     * greater than zero when setting {@code true}. This method
     * should in general be called before the pool is actively used.
     *
     * @param value {@code true} if should time out, else {@code false}
     * @throws IllegalArgumentException if value is {@code true}
     *         and the current keep-alive time is not greater than zero
     *
     * @since 1.6
     */
    public void allowCoreThreadTimeOut(boolean value) {
        /*
         * valueå’ŒkeepAliveTimeå¿…é¡»è®¾ç½®
         */
        if (value && keepAliveTime <= 0)
            throw new IllegalArgumentException("Core threads must have nonzero keep alive times");
        if (value != allowCoreThreadTimeOut) {
            allowCoreThreadTimeOut = value;
            if (value)
                interruptIdleWorkers();
        }
   
```

é€šè¿‡ä¸Šé¢çš„åˆ†æï¼ŒçŒœæµ‹ä¸€ä¸‹è¿™ä¸ªæµ‹è¯•æ–¹æ³•çš„ç»“æœï¼š
```java
    @Test
    public void coreThreadTimeOutTest() {
        /*
         * è®¾ç½®æ ¸å¿ƒçº¿ç¨‹å’Œæœ€å¤§çº¿ç¨‹éƒ½æ˜¯5ä¸ªçš„çº¿ç¨‹æ± 
         */
        ThreadPoolExecutor threadPoolExecutor =
                new ThreadPoolExecutor(5, 5,
                        0L, TimeUnit.MILLISECONDS,
                        new LinkedBlockingQueue<>(),
                        Executors.defaultThreadFactory());
        /*
         * è®¾ç½®æ ¸å¿ƒçº¿ç¨‹è¶…æ—¶æ—¶é—´æ˜¯10ç§’ï¼Œå¯ä»¥é”€æ¯
         */
        threadPoolExecutor.setKeepAliveTime(10, TimeUnit.SECONDS);
        threadPoolExecutor.allowCoreThreadTimeOut(true);

        System.out.println("main thread start");

        /*
         * ä¸æ–­æ‰§è¡Œçº¿ç¨‹ï¼Œçº¿ç¨‹å†…éƒ¨sleep 2ç§’
         */
        for (int i = 0; i < 15; i++) {
            threadPoolExecutor.execute(() -> {
                try {
                    System.out.println("çº¿ç¨‹ï¼š" + Thread.currentThread().getName() + "å¼€å§‹sleep");
                    Thread.sleep(2000);
                    System.out.println("çº¿ç¨‹ï¼š" + Thread.currentThread().getName() + "ç»“æŸsleep");
                } catch (Exception e) {
                    System.out.println("æ‰§è¡Œå¼‚å¸¸");
                }
            });
        }

        /*
         * ä¸»çº¿ç¨‹sleep 40ç§’
         */
        try {
            System.out.println("ä¸»çº¿ç¨‹å¼€å§‹ sleep");
            Thread.sleep(1000 * 40);
        } catch (Exception e) {
            System.out.println("ä¸»çº¿ç¨‹ç»“æŸ sleep");
        }
    }
```
é€šè¿‡è¿™ç¯‡çº¿ç¨‹æ± åšå®¢çš„æ¢³ç†ï¼Œå°†è‡ªå·±ä¹‹å‰çš„å¾ˆå¤šç–‘æƒ‘è§£å†³äº†ï¼Œæ„Ÿè§‰è‡ªå·±æœ‰äº†ä¸€äº›è¿›æ­¥ï¼ŒåŒæ—¶å‚è€ƒäº†å¾ˆå¤šå¤§ç‰›çš„åšå®¢ï¼Œå‘å¤§ç‰›è‡´è°¢ï¼Œæ„Ÿè°¢ä»–ä»¬çš„æŒ‡å¼•ã€‚

## å‚è€ƒ
- [çº¿ç¨‹æ± çš„å·¥ä½œåŸç†ä¸æºç è§£è¯»](https://www.cnblogs.com/qingquanzi/p/8146638.html)
- [Javaå¹¶å‘ç¼–ç¨‹æ€»ç»“5â€”â€”ThreadPoolExecutor](https://www.cnblogs.com/everSeeker/p/5632450.html)
- [æ·±å…¥ç†è§£Javaå¤šçº¿ç¨‹æ ¸å¿ƒçŸ¥è¯†çŸ¥è¯†](https://www.cnblogs.com/lfs2640666960/p/10497806.html)
- [çº¿ç¨‹æ± ---å¦‚ä½•ä¿è¯æ ¸å¿ƒçº¿ç¨‹ä¸è¢«é”€æ¯çš„](https://blog.csdn.net/m0_37039331/article/details/87734270)
- [æ·±å…¥ç†è§£Javaçº¿ç¨‹æ± ï¼šThreadPoolExecutor](http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/)
